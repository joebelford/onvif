/* soapC.c
   Generated by gSOAP 2.8.123 for ./event.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.123 2022-11-17 21:25:12 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_tev__ConnectionStatus:
		return soap_in_tev__ConnectionStatus(soap, tag, NULL, "tev:ConnectionStatus");
	case SOAP_TYPE_tev__EventBrokerProtocol:
		return soap_in_tev__EventBrokerProtocol(soap, tag, NULL, "tev:EventBrokerProtocol");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wstop__TopicType:
		return soap_in_wstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		return soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, NULL, "wsrfr:ResourceUnavailableFaultType");
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		return soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, NULL, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_in_wstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_in_wstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, "wsnt:QueryExpressionType");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_in_wstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_in_wsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_tev__EventBrokerConfig:
		return soap_in_tev__EventBrokerConfig(soap, tag, NULL, "tev:EventBrokerConfig");
	case SOAP_TYPE_tev__Capabilities:
		return soap_in_tev__Capabilities(soap, tag, NULL, "tev:Capabilities");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscriptionResponse:
		return soap_in_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag, NULL, "wsnt:ResumeSubscriptionResponse");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		return soap_in_PointerTo_wsnt__ResumeSubscription(soap, tag, NULL, "wsnt:ResumeSubscription");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscriptionResponse:
		return soap_in_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag, NULL, "wsnt:PauseSubscriptionResponse");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		return soap_in_PointerTo_wsnt__PauseSubscription(soap, tag, NULL, "wsnt:PauseSubscription");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPointResponse:
		return soap_in_PointerTo_wsnt__CreatePullPointResponse(soap, tag, NULL, "wsnt:CreatePullPointResponse");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		return soap_in_PointerTo_wsnt__CreatePullPoint(soap, tag, NULL, "wsnt:CreatePullPoint");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPointResponse:
		return soap_in_PointerTo_wsnt__DestroyPullPointResponse(soap, tag, NULL, "wsnt:DestroyPullPointResponse");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		return soap_in_PointerTo_wsnt__DestroyPullPoint(soap, tag, NULL, "wsnt:DestroyPullPoint");
	case SOAP_TYPE_PointerTo_wsnt__GetMessagesResponse:
		return soap_in_PointerTo_wsnt__GetMessagesResponse(soap, tag, NULL, "wsnt:GetMessagesResponse");
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		return soap_in_PointerTo_wsnt__GetMessages(soap, tag, NULL, "wsnt:GetMessages");
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		return soap_in_PointerTo_wsnt__Notify(soap, tag, NULL, "wsnt:Notify");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessageResponse:
		return soap_in_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag, NULL, "wsnt:GetCurrentMessageResponse");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		return soap_in_PointerTo_wsnt__GetCurrentMessage(soap, tag, NULL, "wsnt:GetCurrentMessage");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeResponse:
		return soap_in_PointerTo_wsnt__SubscribeResponse(soap, tag, NULL, "wsnt:SubscribeResponse");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		return soap_in_PointerTo_wsnt__Subscribe(soap, tag, NULL, "wsnt:Subscribe");
	case SOAP_TYPE_PointerTo_wsnt__RenewResponse:
		return soap_in_PointerTo_wsnt__RenewResponse(soap, tag, NULL, "wsnt:RenewResponse");
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		return soap_in_PointerTo_wsnt__Renew(soap, tag, NULL, "wsnt:Renew");
	case SOAP_TYPE_PointerTo_tev__GetEventBrokersResponse:
		return soap_in_PointerTo_tev__GetEventBrokersResponse(soap, tag, NULL, "tev:GetEventBrokersResponse");
	case SOAP_TYPE_PointerTo_tev__GetEventBrokers:
		return soap_in_PointerTo_tev__GetEventBrokers(soap, tag, NULL, "tev:GetEventBrokers");
	case SOAP_TYPE_PointerTo_tev__DeleteEventBrokerResponse:
		return soap_in_PointerTo_tev__DeleteEventBrokerResponse(soap, tag, NULL, "tev:DeleteEventBrokerResponse");
	case SOAP_TYPE_PointerTo_tev__DeleteEventBroker:
		return soap_in_PointerTo_tev__DeleteEventBroker(soap, tag, NULL, "tev:DeleteEventBroker");
	case SOAP_TYPE_PointerTo_tev__AddEventBrokerResponse:
		return soap_in_PointerTo_tev__AddEventBrokerResponse(soap, tag, NULL, "tev:AddEventBrokerResponse");
	case SOAP_TYPE_PointerTo_tev__AddEventBroker:
		return soap_in_PointerTo_tev__AddEventBroker(soap, tag, NULL, "tev:AddEventBroker");
	case SOAP_TYPE_PointerTo_tev__GetEventPropertiesResponse:
		return soap_in_PointerTo_tev__GetEventPropertiesResponse(soap, tag, NULL, "tev:GetEventPropertiesResponse");
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		return soap_in_PointerTo_tev__GetEventProperties(soap, tag, NULL, "tev:GetEventProperties");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscriptionResponse:
		return soap_in_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag, NULL, "tev:CreatePullPointSubscriptionResponse");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		return soap_in_PointerTo_tev__CreatePullPointSubscription(soap, tag, NULL, "tev:CreatePullPointSubscription");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilitiesResponse:
		return soap_in_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag, NULL, "tev:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		return soap_in_PointerTo_tev__GetServiceCapabilities(soap, tag, NULL, "tev:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_wsnt__UnsubscribeResponse:
		return soap_in_PointerTo_wsnt__UnsubscribeResponse(soap, tag, NULL, "wsnt:UnsubscribeResponse");
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		return soap_in_PointerTo_wsnt__Unsubscribe(soap, tag, NULL, "wsnt:Unsubscribe");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPointResponse:
		return soap_in_PointerTo_tev__SetSynchronizationPointResponse(soap, tag, NULL, "tev:SetSynchronizationPointResponse");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		return soap_in_PointerTo_tev__SetSynchronizationPoint(soap, tag, NULL, "tev:SetSynchronizationPoint");
	case SOAP_TYPE_PointerTo_tev__SeekResponse:
		return soap_in_PointerTo_tev__SeekResponse(soap, tag, NULL, "tev:SeekResponse");
	case SOAP_TYPE_PointerTo_tev__Seek:
		return soap_in_PointerTo_tev__Seek(soap, tag, NULL, "tev:Seek");
	case SOAP_TYPE_PointerTo_tev__PullMessagesResponse:
		return soap_in_PointerTo_tev__PullMessagesResponse(soap, tag, NULL, "tev:PullMessagesResponse");
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		return soap_in_PointerTo_tev__PullMessages(soap, tag, NULL, "tev:PullMessages");
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		return soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		return soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		return soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		return soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		return soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		return soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		return soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		return soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		return soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		return soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		return soap_in_PointerTowsnt__ResumeFailedFaultType(soap, tag, NULL, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		return soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, NULL, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		return soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, tag, NULL, "tev:PullMessagesFaultResponse");
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		return soap_in_PointerTowsnt__PauseFailedFaultType(soap, tag, NULL, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		return soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		return soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		return soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		return soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		return soap_in_PointerTowsnt__InvalidFilterFaultType(soap, tag, NULL, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, NULL, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_in_PointerTowstop__QueryExpressionType(soap, tag, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:ResumeFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, NULL, "wsnt:ResumeFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:ResumeFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:PauseFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, NULL, "wsnt:PauseFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:PauseFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToCreatePullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnableToGetMessagesFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, NULL, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, NULL, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, NULL, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, NULL, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, NULL, "wsnt:TopicNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidTopicExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, NULL, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, NULL, "wsnt:InvalidFilterFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, NULL, "wsnt:InvalidFilterFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, NULL, "wsnt:InvalidFilterFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, NULL, "wsnt:SubscribeCreationFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause:
		return soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, NULL, "wsrfr:ResourceUnavailableFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_Description:
		return soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag, NULL, "wsrfr:ResourceUnavailableFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, NULL, "wsrfr:ResourceUnavailableFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause:
		return soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, NULL, "wsrfr:ResourceUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_Description:
		return soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag, NULL, "wsrfr:ResourceUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, NULL, "wsrfr:ResourceUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_in_PointerTowstop__Documentation(soap, tag, NULL, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, NULL, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, NULL, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, NULL, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, NULL, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, NULL, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTotev__EventBrokerConfig:
		return soap_in_PointerTotev__EventBrokerConfig(soap, tag, NULL, "tev:EventBrokerConfig");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_in_PointerTowstop__TopicSetType(soap, tag, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		return soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, NULL, "tev:CreatePullPointSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTotev__Capabilities:
		return soap_in_PointerTotev__Capabilities(soap, tag, NULL, "tev:Capabilities");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_in_PointerTowsnt__FilterType(soap, tag, NULL, "wsnt:FilterType");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
	{	char **s;
		s = soap_in_wstop__SimpleTopicExpression(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
	{	char **s;
		s = soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, "wstop:ConcreteTopicExpression");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstop__FullTopicExpression:
	{	char **s;
		s = soap_in_wstop__FullTopicExpression(soap, tag, NULL, "wstop:FullTopicExpression");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
	{	char **s;
		s = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, "wsnt:AbsoluteOrRelativeTimeType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, tag, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__nonNegativeInteger:
	{	char **s;
		s = soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{	char **s;
		s = soap_in_xsd__NCName(soap, tag, NULL, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:ConnectionStatus"))
		{	*type = SOAP_TYPE_tev__ConnectionStatus;
			return soap_in_tev__ConnectionStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:EventBrokerProtocol"))
		{	*type = SOAP_TYPE_tev__EventBrokerProtocol;
			return soap_in_tev__EventBrokerProtocol(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicType"))
		{	*type = SOAP_TYPE_wstop__TopicType;
			return soap_in_wstop__TopicType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType"))
		{	*type = SOAP_TYPE_wstop__TopicNamespaceType;
			return soap_in_wstop__TopicNamespaceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__ResumeFailedFaultType;
			return soap_in_wsnt__ResumeFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__PauseFailedFaultType;
			return soap_in_wsnt__PauseFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType;
			return soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType;
			return soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType;
			return soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnableToGetMessagesFaultType;
			return soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType;
			return soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType;
			return soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType;
			return soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType;
			return soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType;
			return soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType;
			return soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicNotSupportedFaultType;
			return soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType;
			return soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType;
			return soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_wsnt__InvalidFilterFaultType;
			return soap_in_wsnt__InvalidFilterFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType;
			return soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFaultType"))
		{	*type = SOAP_TYPE_wsrfr__ResourceUnavailableFaultType;
			return soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFaultType"))
		{	*type = SOAP_TYPE_wsrfr__ResourceUnknownFaultType;
			return soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:QueryExpressionType"))
		{	*type = SOAP_TYPE_wstop__QueryExpressionType;
			return soap_in_wstop__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_wstop__ExtensibleDocumented;
			return soap_in_wstop__ExtensibleDocumented(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:Documentation"))
		{	*type = SOAP_TYPE_wstop__Documentation;
			return soap_in_wstop__Documentation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_wsnt__SubscriptionPolicyType;
			return soap_in_wsnt__SubscriptionPolicyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionType"))
		{	*type = SOAP_TYPE_wsnt__TopicExpressionType;
			return soap_in_wsnt__TopicExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:QueryExpressionType"))
		{	*type = SOAP_TYPE_wsnt__QueryExpressionType;
			return soap_in_wsnt__QueryExpressionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType"))
		{	*type = SOAP_TYPE_wsrfbf__BaseFaultType;
			return soap_in_wsrfbf__BaseFaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSetType"))
		{	*type = SOAP_TYPE_wstop__TopicSetType;
			return soap_in_wstop__TopicSetType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_wsnt__NotificationMessageHolderType;
			return soap_in_wsnt__NotificationMessageHolderType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:FilterType"))
		{	*type = SOAP_TYPE_wsnt__FilterType;
			return soap_in_wsnt__FilterType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:EventBrokerConfig"))
		{	*type = SOAP_TYPE_tev__EventBrokerConfig;
			return soap_in_tev__EventBrokerConfig(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:Capabilities"))
		{	*type = SOAP_TYPE_tev__Capabilities;
			return soap_in_tev__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_wstop__SimpleTopicExpression;
			s = soap_in_wstop__SimpleTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	char **s;
			*type = SOAP_TYPE_wstop__ConcreteTopicExpression;
			s = soap_in_wstop__ConcreteTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wstop:FullTopicExpression"))
		{	char **s;
			*type = SOAP_TYPE_wstop__FullTopicExpression;
			s = soap_in_wstop__FullTopicExpression(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsnt:AbsoluteOrRelativeTimeType"))
		{	char **s;
			*type = SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType;
			s = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	char **s;
			*type = SOAP_TYPE_xsd__nonNegativeInteger;
			s = soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NCName;
			s = soap_in_xsd__NCName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__wstop__TopicNamespaceType_Topic;
			return soap_in__wstop__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause;
			return soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_Description;
			return soap_in__wsnt__ResumeFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode;
			return soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause;
			return soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_Description;
			return soap_in__wsnt__PauseFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode;
			return soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode;
			return soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode;
			return soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToCreatePullPointFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode;
			return soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode;
			return soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause;
			return soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description;
			return soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnableToGetMessagesFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode;
			return soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode;
			return soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode;
			return soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode;
			return soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode;
			return soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode;
			return soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode;
			return soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause;
			return soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description;
			return soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicNotSupportedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode;
			return soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidTopicExpressionFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode;
			return soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode;
			return soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause;
			return soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_Description;
			return soap_in__wsnt__InvalidFilterFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:InvalidFilterFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode;
			return soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-Description"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeCreationFailedFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode;
			return soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause;
			return soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description;
			return soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnavailableFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode;
			return soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause;
			return soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description;
			return soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfr:ResourceUnknownFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode;
			return soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscriptionResponse;
			return soap_in__wsnt__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:ResumeSubscription"))
		{	*type = SOAP_TYPE__wsnt__ResumeSubscription;
			return soap_in__wsnt__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscriptionResponse;
			return soap_in__wsnt__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:PauseSubscription"))
		{	*type = SOAP_TYPE__wsnt__PauseSubscription;
			return soap_in__wsnt__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__UnsubscribeResponse;
			return soap_in__wsnt__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Unsubscribe"))
		{	*type = SOAP_TYPE__wsnt__Unsubscribe;
			return soap_in__wsnt__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:RenewResponse"))
		{	*type = SOAP_TYPE__wsnt__RenewResponse;
			return soap_in__wsnt__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Renew"))
		{	*type = SOAP_TYPE__wsnt__Renew;
			return soap_in__wsnt__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPointResponse;
			return soap_in__wsnt__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:CreatePullPoint"))
		{	*type = SOAP_TYPE__wsnt__CreatePullPoint;
			return soap_in__wsnt__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPointResponse;
			return soap_in__wsnt__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:DestroyPullPoint"))
		{	*type = SOAP_TYPE__wsnt__DestroyPullPoint;
			return soap_in__wsnt__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessagesResponse"))
		{	*type = SOAP_TYPE__wsnt__GetMessagesResponse;
			return soap_in__wsnt__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetMessages"))
		{	*type = SOAP_TYPE__wsnt__GetMessages;
			return soap_in__wsnt__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessageResponse;
			return soap_in__wsnt__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:GetCurrentMessage"))
		{	*type = SOAP_TYPE__wsnt__GetCurrentMessage;
			return soap_in__wsnt__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscribeResponse"))
		{	*type = SOAP_TYPE__wsnt__SubscribeResponse;
			return soap_in__wsnt__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy;
			return soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Subscribe"))
		{	*type = SOAP_TYPE__wsnt__Subscribe;
			return soap_in__wsnt__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:UseRaw"))
		{	*type = SOAP_TYPE__wsnt__UseRaw;
			return soap_in__wsnt__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:Notify"))
		{	*type = SOAP_TYPE__wsnt__Notify;
			return soap_in__wsnt__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__wsnt__SubscriptionManagerRP;
			return soap_in__wsnt__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationProducerRP"))
		{	*type = SOAP_TYPE__wsnt__NotificationProducerRP;
			return soap_in__wsnt__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnt:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__wsnt__NotificationMessageHolderType_Message;
			return soap_in__wsnt__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause;
			return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_Description;
			return soap_in__wsrfbf__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode;
			return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventBrokersResponse"))
		{	*type = SOAP_TYPE__tev__GetEventBrokersResponse;
			return soap_in__tev__GetEventBrokersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventBrokers"))
		{	*type = SOAP_TYPE__tev__GetEventBrokers;
			return soap_in__tev__GetEventBrokers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:DeleteEventBrokerResponse"))
		{	*type = SOAP_TYPE__tev__DeleteEventBrokerResponse;
			return soap_in__tev__DeleteEventBrokerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:DeleteEventBroker"))
		{	*type = SOAP_TYPE__tev__DeleteEventBroker;
			return soap_in__tev__DeleteEventBroker(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:AddEventBrokerResponse"))
		{	*type = SOAP_TYPE__tev__AddEventBrokerResponse;
			return soap_in__tev__AddEventBrokerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:AddEventBroker"))
		{	*type = SOAP_TYPE__tev__AddEventBroker;
			return soap_in__tev__AddEventBroker(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventPropertiesResponse"))
		{	*type = SOAP_TYPE__tev__GetEventPropertiesResponse;
			return soap_in__tev__GetEventPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetEventProperties"))
		{	*type = SOAP_TYPE__tev__GetEventProperties;
			return soap_in__tev__GetEventProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SetSynchronizationPointResponse"))
		{	*type = SOAP_TYPE__tev__SetSynchronizationPointResponse;
			return soap_in__tev__SetSynchronizationPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SetSynchronizationPoint"))
		{	*type = SOAP_TYPE__tev__SetSynchronizationPoint;
			return soap_in__tev__SetSynchronizationPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:SeekResponse"))
		{	*type = SOAP_TYPE__tev__SeekResponse;
			return soap_in__tev__SeekResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:Seek"))
		{	*type = SOAP_TYPE__tev__Seek;
			return soap_in__tev__Seek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessagesFaultResponse"))
		{	*type = SOAP_TYPE__tev__PullMessagesFaultResponse;
			return soap_in__tev__PullMessagesFaultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessagesResponse"))
		{	*type = SOAP_TYPE__tev__PullMessagesResponse;
			return soap_in__tev__PullMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:PullMessages"))
		{	*type = SOAP_TYPE__tev__PullMessages;
			return soap_in__tev__PullMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscriptionResponse"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscriptionResponse;
			return soap_in__tev__CreatePullPointSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscription-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy;
			return soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:CreatePullPointSubscription"))
		{	*type = SOAP_TYPE__tev__CreatePullPointSubscription;
			return soap_in__tev__CreatePullPointSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tev__GetServiceCapabilitiesResponse;
			return soap_in__tev__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tev:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__tev__GetServiceCapabilities;
			return soap_in__tev__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	char **s;
			*type = SOAP_TYPE__xml__lang;
			s = soap_in__xml__lang(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_tev__ConnectionStatus:
		return soap_out_tev__ConnectionStatus(soap, tag, id, (const enum tev__ConnectionStatus *)ptr, "tev:ConnectionStatus");
	case SOAP_TYPE_tev__EventBrokerProtocol:
		return soap_out_tev__EventBrokerProtocol(soap, tag, id, (const enum tev__EventBrokerProtocol *)ptr, "tev:EventBrokerProtocol");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_wstop__TopicType:
		return soap_out_wstop__TopicType(soap, tag, id, (const struct wstop__TopicType *)ptr, "wstop:TopicType");
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:TopicNamespaceType-Topic", id, (const struct _wstop__TopicNamespaceType_Topic *)ptr, "");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_out_wstop__TopicNamespaceType(soap, tag, id, (const struct wstop__TopicNamespaceType *)ptr, "wstop:TopicNamespaceType");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause:
		return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, "wsnt:ResumeFailedFaultType-FaultCause", id, (const struct _wsnt__ResumeFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_Description:
		return soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsnt:ResumeFailedFaultType-Description", id, (const struct _wsnt__ResumeFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsnt:ResumeFailedFaultType-ErrorCode", id, (const struct _wsnt__ResumeFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, (const struct wsnt__ResumeFailedFaultType *)ptr, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause:
		return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, "wsnt:PauseFailedFaultType-FaultCause", id, (const struct _wsnt__PauseFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_Description:
		return soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsnt:PauseFailedFaultType-Description", id, (const struct _wsnt__PauseFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode:
		return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, "wsnt:PauseFailedFaultType-ErrorCode", id, (const struct _wsnt__PauseFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, (const struct wsnt__PauseFailedFaultType *)ptr, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsnt:UnableToDestroySubscriptionFaultType-Description", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", id, (const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, (const struct wsnt__UnableToDestroySubscriptionFaultType *)ptr, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsnt:UnacceptableTerminationTimeFaultType-Description", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", id, (const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, (const struct wsnt__UnacceptableTerminationTimeFaultType *)ptr, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsnt:UnableToCreatePullPointFaultType-FaultCause", id, (const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsnt:UnableToCreatePullPointFaultType-Description", id, (const struct _wsnt__UnableToCreatePullPointFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsnt:UnableToCreatePullPointFaultType-ErrorCode", id, (const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, (const struct wsnt__UnableToCreatePullPointFaultType *)ptr, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsnt:UnableToDestroyPullPointFaultType-FaultCause", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsnt:UnableToDestroyPullPointFaultType-Description", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", id, (const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, (const struct wsnt__UnableToDestroyPullPointFaultType *)ptr, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsnt:UnableToGetMessagesFaultType-FaultCause", id, (const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description:
		return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsnt:UnableToGetMessagesFaultType-Description", id, (const struct _wsnt__UnableToGetMessagesFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsnt:UnableToGetMessagesFaultType-ErrorCode", id, (const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, (const struct wsnt__UnableToGetMessagesFaultType *)ptr, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsnt:NoCurrentMessageOnTopicFaultType-Description", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", id, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, (const struct wsnt__NoCurrentMessageOnTopicFaultType *)ptr, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", id, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (const struct wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsnt:NotifyMessageNotSupportedFaultType-Description", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", id, (const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, (const struct wsnt__NotifyMessageNotSupportedFaultType *)ptr, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsnt:UnsupportedPolicyRequestFaultType-Description", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", id, (const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, (const struct wsnt__UnsupportedPolicyRequestFaultType *)ptr, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsnt:UnrecognizedPolicyRequestFaultType-Description", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", id, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, (const struct wsnt__UnrecognizedPolicyRequestFaultType *)ptr, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsnt:InvalidMessageContentExpressionFaultType-Description", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidMessageContentExpressionFaultType *)ptr, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsnt:MultipleTopicsSpecifiedFaultType-Description", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", id, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, (const struct wsnt__MultipleTopicsSpecifiedFaultType *)ptr, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsnt:TopicNotSupportedFaultType-FaultCause", id, (const struct _wsnt__TopicNotSupportedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description:
		return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsnt:TopicNotSupportedFaultType-Description", id, (const struct _wsnt__TopicNotSupportedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsnt:TopicNotSupportedFaultType-ErrorCode", id, (const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, (const struct wsnt__TopicNotSupportedFaultType *)ptr, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsnt:InvalidTopicExpressionFaultType-FaultCause", id, (const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsnt:InvalidTopicExpressionFaultType-Description", id, (const struct _wsnt__InvalidTopicExpressionFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsnt:InvalidTopicExpressionFaultType-ErrorCode", id, (const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, (const struct wsnt__InvalidTopicExpressionFaultType *)ptr, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsnt:TopicExpressionDialectUnknownFaultType-Description", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", id, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, (const struct wsnt__TopicExpressionDialectUnknownFaultType *)ptr, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause:
		return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, "wsnt:InvalidFilterFaultType-FaultCause", id, (const struct _wsnt__InvalidFilterFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_Description:
		return soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsnt:InvalidFilterFaultType-Description", id, (const struct _wsnt__InvalidFilterFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsnt:InvalidFilterFaultType-ErrorCode", id, (const struct _wsnt__InvalidFilterFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, (const struct wsnt__InvalidFilterFaultType *)ptr, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsnt:SubscribeCreationFailedFaultType-FaultCause", id, (const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsnt:SubscribeCreationFailedFaultType-Description", id, (const struct _wsnt__SubscribeCreationFailedFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsnt:SubscribeCreationFailedFaultType-ErrorCode", id, (const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, (const struct wsnt__SubscribeCreationFailedFaultType *)ptr, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause:
		return soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfr:ResourceUnavailableFaultType-FaultCause", id, (const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description:
		return soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfr:ResourceUnavailableFaultType-Description", id, (const struct _wsrfr__ResourceUnavailableFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode:
		return soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfr:ResourceUnavailableFaultType-ErrorCode", id, (const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		return soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag, id, (const struct wsrfr__ResourceUnavailableFaultType *)ptr, "wsrfr:ResourceUnavailableFaultType");
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause:
		return soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfr:ResourceUnknownFaultType-FaultCause", id, (const struct _wsrfr__ResourceUnknownFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description:
		return soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfr:ResourceUnknownFaultType-Description", id, (const struct _wsrfr__ResourceUnknownFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode:
		return soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfr:ResourceUnknownFaultType-ErrorCode", id, (const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		return soap_out_wsrfr__ResourceUnknownFaultType(soap, tag, id, (const struct wsrfr__ResourceUnknownFaultType *)ptr, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_out_wstop__QueryExpressionType(soap, tag, id, (const struct wstop__QueryExpressionType *)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_out_wstop__ExtensibleDocumented(soap, tag, id, (const struct wstop__ExtensibleDocumented *)ptr, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_out_wstop__Documentation(soap, tag, id, (const struct wstop__Documentation *)ptr, "wstop:Documentation");
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		return soap_out__wsnt__ResumeSubscriptionResponse(soap, "wsnt:ResumeSubscriptionResponse", id, (const struct _wsnt__ResumeSubscriptionResponse *)ptr, "");
	case SOAP_TYPE__wsnt__ResumeSubscription:
		return soap_out__wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", id, (const struct _wsnt__ResumeSubscription *)ptr, "");
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		return soap_out__wsnt__PauseSubscriptionResponse(soap, "wsnt:PauseSubscriptionResponse", id, (const struct _wsnt__PauseSubscriptionResponse *)ptr, "");
	case SOAP_TYPE__wsnt__PauseSubscription:
		return soap_out__wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", id, (const struct _wsnt__PauseSubscription *)ptr, "");
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		return soap_out__wsnt__UnsubscribeResponse(soap, "wsnt:UnsubscribeResponse", id, (const struct _wsnt__UnsubscribeResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Unsubscribe:
		return soap_out__wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", id, (const struct _wsnt__Unsubscribe *)ptr, "");
	case SOAP_TYPE__wsnt__RenewResponse:
		return soap_out__wsnt__RenewResponse(soap, "wsnt:RenewResponse", id, (const struct _wsnt__RenewResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Renew:
		return soap_out__wsnt__Renew(soap, "wsnt:Renew", id, (const struct _wsnt__Renew *)ptr, "");
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		return soap_out__wsnt__CreatePullPointResponse(soap, "wsnt:CreatePullPointResponse", id, (const struct _wsnt__CreatePullPointResponse *)ptr, "");
	case SOAP_TYPE__wsnt__CreatePullPoint:
		return soap_out__wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", id, (const struct _wsnt__CreatePullPoint *)ptr, "");
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		return soap_out__wsnt__DestroyPullPointResponse(soap, "wsnt:DestroyPullPointResponse", id, (const struct _wsnt__DestroyPullPointResponse *)ptr, "");
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		return soap_out__wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", id, (const struct _wsnt__DestroyPullPoint *)ptr, "");
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		return soap_out__wsnt__GetMessagesResponse(soap, "wsnt:GetMessagesResponse", id, (const struct _wsnt__GetMessagesResponse *)ptr, "");
	case SOAP_TYPE__wsnt__GetMessages:
		return soap_out__wsnt__GetMessages(soap, "wsnt:GetMessages", id, (const struct _wsnt__GetMessages *)ptr, "");
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		return soap_out__wsnt__GetCurrentMessageResponse(soap, "wsnt:GetCurrentMessageResponse", id, (const struct _wsnt__GetCurrentMessageResponse *)ptr, "");
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		return soap_out__wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", id, (const struct _wsnt__GetCurrentMessage *)ptr, "");
	case SOAP_TYPE__wsnt__SubscribeResponse:
		return soap_out__wsnt__SubscribeResponse(soap, "wsnt:SubscribeResponse", id, (const struct _wsnt__SubscribeResponse *)ptr, "");
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:Subscribe-SubscriptionPolicy", id, (const struct _wsnt__Subscribe_SubscriptionPolicy *)ptr, "");
	case SOAP_TYPE__wsnt__Subscribe:
		return soap_out__wsnt__Subscribe(soap, "wsnt:Subscribe", id, (const struct _wsnt__Subscribe *)ptr, "");
	case SOAP_TYPE__wsnt__UseRaw:
		return soap_out__wsnt__UseRaw(soap, "wsnt:UseRaw", id, (const struct _wsnt__UseRaw *)ptr, "");
	case SOAP_TYPE__wsnt__Notify:
		return soap_out__wsnt__Notify(soap, "wsnt:Notify", id, (const struct _wsnt__Notify *)ptr, "");
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		return soap_out__wsnt__SubscriptionManagerRP(soap, "wsnt:SubscriptionManagerRP", id, (const struct _wsnt__SubscriptionManagerRP *)ptr, "");
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		return soap_out__wsnt__NotificationProducerRP(soap, "wsnt:NotificationProducerRP", id, (const struct _wsnt__NotificationProducerRP *)ptr, "");
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		return soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:NotificationMessageHolderType-Message", id, (const struct _wsnt__NotificationMessageHolderType_Message *)ptr, "");
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, (const struct wsnt__SubscriptionPolicyType *)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_wsnt__TopicExpressionType:
		return soap_out_wsnt__TopicExpressionType(soap, tag, id, (const struct wsnt__TopicExpressionType *)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_wsnt__QueryExpressionType:
		return soap_out_wsnt__QueryExpressionType(soap, tag, id, (const struct wsnt__QueryExpressionType *)ptr, "wsnt:QueryExpressionType");
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:BaseFaultType-FaultCause", id, (const struct _wsrfbf__BaseFaultType_FaultCause *)ptr, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return soap_out__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:BaseFaultType-Description", id, (const struct _wsrfbf__BaseFaultType_Description *)ptr, "");
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:BaseFaultType-ErrorCode", id, (const struct _wsrfbf__BaseFaultType_ErrorCode *)ptr, "");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_out_wsrfbf__BaseFaultType(soap, tag, id, (const struct wsrfbf__BaseFaultType *)ptr, "wsrfbf:BaseFaultType");
	case SOAP_TYPE__tev__GetEventBrokersResponse:
		return soap_out__tev__GetEventBrokersResponse(soap, "tev:GetEventBrokersResponse", id, (const struct _tev__GetEventBrokersResponse *)ptr, "");
	case SOAP_TYPE__tev__GetEventBrokers:
		return soap_out__tev__GetEventBrokers(soap, "tev:GetEventBrokers", id, (const struct _tev__GetEventBrokers *)ptr, "");
	case SOAP_TYPE__tev__DeleteEventBrokerResponse:
		return soap_out__tev__DeleteEventBrokerResponse(soap, "tev:DeleteEventBrokerResponse", id, (const struct _tev__DeleteEventBrokerResponse *)ptr, "");
	case SOAP_TYPE__tev__DeleteEventBroker:
		return soap_out__tev__DeleteEventBroker(soap, "tev:DeleteEventBroker", id, (const struct _tev__DeleteEventBroker *)ptr, "");
	case SOAP_TYPE__tev__AddEventBrokerResponse:
		return soap_out__tev__AddEventBrokerResponse(soap, "tev:AddEventBrokerResponse", id, (const struct _tev__AddEventBrokerResponse *)ptr, "");
	case SOAP_TYPE__tev__AddEventBroker:
		return soap_out__tev__AddEventBroker(soap, "tev:AddEventBroker", id, (const struct _tev__AddEventBroker *)ptr, "");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_out_wstop__TopicSetType(soap, tag, id, (const struct wstop__TopicSetType *)ptr, "wstop:TopicSetType");
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		return soap_out__tev__GetEventPropertiesResponse(soap, "tev:GetEventPropertiesResponse", id, (const struct _tev__GetEventPropertiesResponse *)ptr, "");
	case SOAP_TYPE__tev__GetEventProperties:
		return soap_out__tev__GetEventProperties(soap, "tev:GetEventProperties", id, (const struct _tev__GetEventProperties *)ptr, "");
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		return soap_out__tev__SetSynchronizationPointResponse(soap, "tev:SetSynchronizationPointResponse", id, (const struct _tev__SetSynchronizationPointResponse *)ptr, "");
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		return soap_out__tev__SetSynchronizationPoint(soap, "tev:SetSynchronizationPoint", id, (const struct _tev__SetSynchronizationPoint *)ptr, "");
	case SOAP_TYPE__tev__SeekResponse:
		return soap_out__tev__SeekResponse(soap, "tev:SeekResponse", id, (const struct _tev__SeekResponse *)ptr, "");
	case SOAP_TYPE__tev__Seek:
		return soap_out__tev__Seek(soap, "tev:Seek", id, (const struct _tev__Seek *)ptr, "");
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		return soap_out__tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", id, (const struct _tev__PullMessagesFaultResponse *)ptr, "");
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, (const struct wsnt__NotificationMessageHolderType *)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE__tev__PullMessagesResponse:
		return soap_out__tev__PullMessagesResponse(soap, "tev:PullMessagesResponse", id, (const struct _tev__PullMessagesResponse *)ptr, "");
	case SOAP_TYPE__tev__PullMessages:
		return soap_out__tev__PullMessages(soap, "tev:PullMessages", id, (const struct _tev__PullMessages *)ptr, "");
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		return soap_out__tev__CreatePullPointSubscriptionResponse(soap, "tev:CreatePullPointSubscriptionResponse", id, (const struct _tev__CreatePullPointSubscriptionResponse *)ptr, "");
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		return soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:CreatePullPointSubscription-SubscriptionPolicy", id, (const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)ptr, "");
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		return soap_out__tev__CreatePullPointSubscription(soap, "tev:CreatePullPointSubscription", id, (const struct _tev__CreatePullPointSubscription *)ptr, "");
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		return soap_out__tev__GetServiceCapabilitiesResponse(soap, "tev:GetServiceCapabilitiesResponse", id, (const struct _tev__GetServiceCapabilitiesResponse *)ptr, "");
	case SOAP_TYPE__tev__GetServiceCapabilities:
		return soap_out__tev__GetServiceCapabilities(soap, "tev:GetServiceCapabilities", id, (const struct _tev__GetServiceCapabilities *)ptr, "");
	case SOAP_TYPE_wsnt__FilterType:
		return soap_out_wsnt__FilterType(soap, tag, id, (const struct wsnt__FilterType *)ptr, "wsnt:FilterType");
	case SOAP_TYPE_tev__EventBrokerConfig:
		return soap_out_tev__EventBrokerConfig(soap, tag, id, (const struct tev__EventBrokerConfig *)ptr, "tev:EventBrokerConfig");
	case SOAP_TYPE_tev__Capabilities:
		return soap_out_tev__Capabilities(soap, tag, id, (const struct tev__Capabilities *)ptr, "tev:Capabilities");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscriptionResponse:
		return soap_out_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag, id, (struct _wsnt__ResumeSubscriptionResponse *const*)ptr, "wsnt:ResumeSubscriptionResponse");
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		return soap_out_PointerTo_wsnt__ResumeSubscription(soap, tag, id, (struct _wsnt__ResumeSubscription *const*)ptr, "wsnt:ResumeSubscription");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscriptionResponse:
		return soap_out_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag, id, (struct _wsnt__PauseSubscriptionResponse *const*)ptr, "wsnt:PauseSubscriptionResponse");
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		return soap_out_PointerTo_wsnt__PauseSubscription(soap, tag, id, (struct _wsnt__PauseSubscription *const*)ptr, "wsnt:PauseSubscription");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPointResponse:
		return soap_out_PointerTo_wsnt__CreatePullPointResponse(soap, tag, id, (struct _wsnt__CreatePullPointResponse *const*)ptr, "wsnt:CreatePullPointResponse");
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		return soap_out_PointerTo_wsnt__CreatePullPoint(soap, tag, id, (struct _wsnt__CreatePullPoint *const*)ptr, "wsnt:CreatePullPoint");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPointResponse:
		return soap_out_PointerTo_wsnt__DestroyPullPointResponse(soap, tag, id, (struct _wsnt__DestroyPullPointResponse *const*)ptr, "wsnt:DestroyPullPointResponse");
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		return soap_out_PointerTo_wsnt__DestroyPullPoint(soap, tag, id, (struct _wsnt__DestroyPullPoint *const*)ptr, "wsnt:DestroyPullPoint");
	case SOAP_TYPE_PointerTo_wsnt__GetMessagesResponse:
		return soap_out_PointerTo_wsnt__GetMessagesResponse(soap, tag, id, (struct _wsnt__GetMessagesResponse *const*)ptr, "wsnt:GetMessagesResponse");
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		return soap_out_PointerTo_wsnt__GetMessages(soap, tag, id, (struct _wsnt__GetMessages *const*)ptr, "wsnt:GetMessages");
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		return soap_out_PointerTo_wsnt__Notify(soap, tag, id, (struct _wsnt__Notify *const*)ptr, "wsnt:Notify");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessageResponse:
		return soap_out_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag, id, (struct _wsnt__GetCurrentMessageResponse *const*)ptr, "wsnt:GetCurrentMessageResponse");
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		return soap_out_PointerTo_wsnt__GetCurrentMessage(soap, tag, id, (struct _wsnt__GetCurrentMessage *const*)ptr, "wsnt:GetCurrentMessage");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeResponse:
		return soap_out_PointerTo_wsnt__SubscribeResponse(soap, tag, id, (struct _wsnt__SubscribeResponse *const*)ptr, "wsnt:SubscribeResponse");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		return soap_out_PointerTo_wsnt__Subscribe(soap, tag, id, (struct _wsnt__Subscribe *const*)ptr, "wsnt:Subscribe");
	case SOAP_TYPE_PointerTo_wsnt__RenewResponse:
		return soap_out_PointerTo_wsnt__RenewResponse(soap, tag, id, (struct _wsnt__RenewResponse *const*)ptr, "wsnt:RenewResponse");
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		return soap_out_PointerTo_wsnt__Renew(soap, tag, id, (struct _wsnt__Renew *const*)ptr, "wsnt:Renew");
	case SOAP_TYPE_PointerTo_tev__GetEventBrokersResponse:
		return soap_out_PointerTo_tev__GetEventBrokersResponse(soap, tag, id, (struct _tev__GetEventBrokersResponse *const*)ptr, "tev:GetEventBrokersResponse");
	case SOAP_TYPE_PointerTo_tev__GetEventBrokers:
		return soap_out_PointerTo_tev__GetEventBrokers(soap, tag, id, (struct _tev__GetEventBrokers *const*)ptr, "tev:GetEventBrokers");
	case SOAP_TYPE_PointerTo_tev__DeleteEventBrokerResponse:
		return soap_out_PointerTo_tev__DeleteEventBrokerResponse(soap, tag, id, (struct _tev__DeleteEventBrokerResponse *const*)ptr, "tev:DeleteEventBrokerResponse");
	case SOAP_TYPE_PointerTo_tev__DeleteEventBroker:
		return soap_out_PointerTo_tev__DeleteEventBroker(soap, tag, id, (struct _tev__DeleteEventBroker *const*)ptr, "tev:DeleteEventBroker");
	case SOAP_TYPE_PointerTo_tev__AddEventBrokerResponse:
		return soap_out_PointerTo_tev__AddEventBrokerResponse(soap, tag, id, (struct _tev__AddEventBrokerResponse *const*)ptr, "tev:AddEventBrokerResponse");
	case SOAP_TYPE_PointerTo_tev__AddEventBroker:
		return soap_out_PointerTo_tev__AddEventBroker(soap, tag, id, (struct _tev__AddEventBroker *const*)ptr, "tev:AddEventBroker");
	case SOAP_TYPE_PointerTo_tev__GetEventPropertiesResponse:
		return soap_out_PointerTo_tev__GetEventPropertiesResponse(soap, tag, id, (struct _tev__GetEventPropertiesResponse *const*)ptr, "tev:GetEventPropertiesResponse");
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		return soap_out_PointerTo_tev__GetEventProperties(soap, tag, id, (struct _tev__GetEventProperties *const*)ptr, "tev:GetEventProperties");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscriptionResponse:
		return soap_out_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag, id, (struct _tev__CreatePullPointSubscriptionResponse *const*)ptr, "tev:CreatePullPointSubscriptionResponse");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		return soap_out_PointerTo_tev__CreatePullPointSubscription(soap, tag, id, (struct _tev__CreatePullPointSubscription *const*)ptr, "tev:CreatePullPointSubscription");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilitiesResponse:
		return soap_out_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag, id, (struct _tev__GetServiceCapabilitiesResponse *const*)ptr, "tev:GetServiceCapabilitiesResponse");
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		return soap_out_PointerTo_tev__GetServiceCapabilities(soap, tag, id, (struct _tev__GetServiceCapabilities *const*)ptr, "tev:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_wsnt__UnsubscribeResponse:
		return soap_out_PointerTo_wsnt__UnsubscribeResponse(soap, tag, id, (struct _wsnt__UnsubscribeResponse *const*)ptr, "wsnt:UnsubscribeResponse");
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		return soap_out_PointerTo_wsnt__Unsubscribe(soap, tag, id, (struct _wsnt__Unsubscribe *const*)ptr, "wsnt:Unsubscribe");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPointResponse:
		return soap_out_PointerTo_tev__SetSynchronizationPointResponse(soap, tag, id, (struct _tev__SetSynchronizationPointResponse *const*)ptr, "tev:SetSynchronizationPointResponse");
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		return soap_out_PointerTo_tev__SetSynchronizationPoint(soap, tag, id, (struct _tev__SetSynchronizationPoint *const*)ptr, "tev:SetSynchronizationPoint");
	case SOAP_TYPE_PointerTo_tev__SeekResponse:
		return soap_out_PointerTo_tev__SeekResponse(soap, tag, id, (struct _tev__SeekResponse *const*)ptr, "tev:SeekResponse");
	case SOAP_TYPE_PointerTo_tev__Seek:
		return soap_out_PointerTo_tev__Seek(soap, tag, id, (struct _tev__Seek *const*)ptr, "tev:Seek");
	case SOAP_TYPE_PointerTo_tev__PullMessagesResponse:
		return soap_out_PointerTo_tev__PullMessagesResponse(soap, tag, id, (struct _tev__PullMessagesResponse *const*)ptr, "tev:PullMessagesResponse");
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		return soap_out_PointerTo_tev__PullMessages(soap, tag, id, (struct _tev__PullMessages *const*)ptr, "tev:PullMessages");
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		return soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, (struct wsnt__UnsupportedPolicyRequestFaultType *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		return soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, (struct wsnt__UnrecognizedPolicyRequestFaultType *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		return soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, (struct wsnt__UnacceptableTerminationTimeFaultType *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		return soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, (struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		return soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, id, (struct wsnt__UnableToGetMessagesFaultType *const*)ptr, "wsnt:UnableToGetMessagesFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		return soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, (struct wsnt__UnableToDestroySubscriptionFaultType *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		return soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, id, (struct wsnt__UnableToDestroyPullPointFaultType *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		return soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, id, (struct wsnt__UnableToCreatePullPointFaultType *const*)ptr, "wsnt:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		return soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, id, (struct wsnt__TopicNotSupportedFaultType *const*)ptr, "wsnt:TopicNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		return soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, (struct wsnt__TopicExpressionDialectUnknownFaultType *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		return soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, id, (struct wsnt__SubscribeCreationFailedFaultType *const*)ptr, "wsnt:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		return soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag, id, (struct wsnt__ResumeFailedFaultType *const*)ptr, "wsnt:ResumeFailedFaultType");
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		return soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, id, (struct wsrfr__ResourceUnknownFaultType *const*)ptr, "wsrfr:ResourceUnknownFaultType");
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		return soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag, id, (struct _tev__PullMessagesFaultResponse *const*)ptr, "tev:PullMessagesFaultResponse");
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		return soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag, id, (struct wsnt__PauseFailedFaultType *const*)ptr, "wsnt:PauseFailedFaultType");
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		return soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, (struct wsnt__NotifyMessageNotSupportedFaultType *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		return soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, (struct wsnt__NoCurrentMessageOnTopicFaultType *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		return soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, (struct wsnt__MultipleTopicsSpecifiedFaultType *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, id, (struct wsnt__InvalidTopicExpressionFaultType *const*)ptr, "wsnt:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, (struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		return soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, (struct wsnt__InvalidMessageContentExpressionFaultType *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		return soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag, id, (struct wsnt__InvalidFilterFaultType *const*)ptr, "wsnt:InvalidFilterFaultType");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, id, (struct _wstop__TopicNamespaceType_Topic *const*)ptr, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_out_PointerTowstop__TopicType(soap, tag, id, (struct wstop__TopicType *const*)ptr, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_out_PointerTowstop__QueryExpressionType(soap, tag, id, (struct wstop__QueryExpressionType *const*)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_FaultCause *const*)ptr, "wsnt:ResumeFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_Description *const*)ptr, "wsnt:ResumeFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__ResumeFailedFaultType_ErrorCode *const*)ptr, "wsnt:ResumeFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__PauseFailedFaultType_FaultCause *const*)ptr, "wsnt:PauseFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, id, (struct _wsnt__PauseFailedFaultType_Description *const*)ptr, "wsnt:PauseFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__PauseFailedFaultType_ErrorCode *const*)ptr, "wsnt:PauseFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*)ptr, "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*)ptr, "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_Description *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*)ptr, "wsnt:UnableToCreatePullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*)ptr, "wsnt:UnableToDestroyPullPointFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*)ptr, "wsnt:UnableToGetMessagesFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_Description *const*)ptr, "wsnt:UnableToGetMessagesFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*)ptr, "wsnt:UnableToGetMessagesFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*)ptr, "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*)ptr, "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*)ptr, "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*)ptr, "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*)ptr, "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*)ptr, "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*)ptr, "wsnt:TopicNotSupportedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_Description *const*)ptr, "wsnt:TopicNotSupportedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*)ptr, "wsnt:TopicNotSupportedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_Description *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*)ptr, "wsnt:InvalidTopicExpressionFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*)ptr, "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_FaultCause *const*)ptr, "wsnt:InvalidFilterFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_Description *const*)ptr, "wsnt:InvalidFilterFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, (struct _wsnt__InvalidFilterFaultType_ErrorCode *const*)ptr, "wsnt:InvalidFilterFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_Description *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-Description");
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		return soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*)ptr, "wsnt:SubscribeCreationFailedFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause:
		return soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, id, (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*)ptr, "wsrfr:ResourceUnavailableFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_Description:
		return soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag, id, (struct _wsrfr__ResourceUnavailableFaultType_Description *const*)ptr, "wsrfr:ResourceUnavailableFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, id, (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*)ptr, "wsrfr:ResourceUnavailableFaultType-ErrorCode");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause:
		return soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, id, (struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*)ptr, "wsrfr:ResourceUnknownFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_Description:
		return soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag, id, (struct _wsrfr__ResourceUnknownFaultType_Description *const*)ptr, "wsrfr:ResourceUnknownFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, id, (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*)ptr, "wsrfr:ResourceUnknownFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_out_PointerTowstop__Documentation(soap, tag, id, (struct wstop__Documentation *const*)ptr, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, (struct _wsnt__Subscribe_SubscriptionPolicy *const*)ptr, "wsnt:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		return soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag, id, (struct wsnt__SubscriptionPolicyType *const*)ptr, "wsnt:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		return soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, (struct wsnt__TopicExpressionType *const*)ptr, "wsnt:TopicExpressionType");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, id, (struct _wsrfbf__BaseFaultType_FaultCause *const*)ptr, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, id, (struct _wsrfbf__BaseFaultType_Description *const*)ptr, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, (struct _wsrfbf__BaseFaultType_ErrorCode *const*)ptr, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTotev__EventBrokerConfig:
		return soap_out_PointerTotev__EventBrokerConfig(soap, tag, id, (struct tev__EventBrokerConfig *const*)ptr, "tev:EventBrokerConfig");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_out_PointerTowstop__TopicSetType(soap, tag, id, (struct wstop__TopicSetType *const*)ptr, "wstop:TopicSetType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (char **const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, (struct wsnt__NotificationMessageHolderType *const*)ptr, "wsnt:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		return soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*)ptr, "tev:CreatePullPointSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTotev__Capabilities:
		return soap_out_PointerTotev__Capabilities(soap, tag, id, (struct tev__Capabilities *const*)ptr, "tev:Capabilities");
	case SOAP_TYPE_PointerTowsnt__FilterType:
		return soap_out_PointerTowsnt__FilterType(soap, tag, id, (struct wsnt__FilterType *const*)ptr, "wsnt:FilterType");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wstop:FullTopicExpression");
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsnt:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE__xml__lang:
		return soap_out_string(soap, "xml:lang", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___tev__ResumeSubscription:
		soap_serialize___tev__ResumeSubscription(soap, (const struct __tev__ResumeSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__PauseSubscription:
		soap_serialize___tev__PauseSubscription(soap, (const struct __tev__PauseSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe__:
		soap_serialize___tev__Unsubscribe__(soap, (const struct __tev__Unsubscribe__ *)ptr);
		break;
	case SOAP_TYPE___tev__Renew_:
		soap_serialize___tev__Renew_(soap, (const struct __tev__Renew_ *)ptr);
		break;
	case SOAP_TYPE___tev__CreatePullPoint:
		soap_serialize___tev__CreatePullPoint(soap, (const struct __tev__CreatePullPoint *)ptr);
		break;
	case SOAP_TYPE___tev__Notify_:
		soap_serialize___tev__Notify_(soap, (const struct __tev__Notify_ *)ptr);
		break;
	case SOAP_TYPE___tev__DestroyPullPoint:
		soap_serialize___tev__DestroyPullPoint(soap, (const struct __tev__DestroyPullPoint *)ptr);
		break;
	case SOAP_TYPE___tev__GetMessages:
		soap_serialize___tev__GetMessages(soap, (const struct __tev__GetMessages *)ptr);
		break;
	case SOAP_TYPE___tev__Notify:
		soap_serialize___tev__Notify(soap, (const struct __tev__Notify *)ptr);
		break;
	case SOAP_TYPE___tev__GetCurrentMessage:
		soap_serialize___tev__GetCurrentMessage(soap, (const struct __tev__GetCurrentMessage *)ptr);
		break;
	case SOAP_TYPE___tev__Subscribe:
		soap_serialize___tev__Subscribe(soap, (const struct __tev__Subscribe *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe_:
		soap_serialize___tev__Unsubscribe_(soap, (const struct __tev__Unsubscribe_ *)ptr);
		break;
	case SOAP_TYPE___tev__Renew:
		soap_serialize___tev__Renew(soap, (const struct __tev__Renew *)ptr);
		break;
	case SOAP_TYPE___tev__GetEventBrokers:
		soap_serialize___tev__GetEventBrokers(soap, (const struct __tev__GetEventBrokers *)ptr);
		break;
	case SOAP_TYPE___tev__DeleteEventBroker:
		soap_serialize___tev__DeleteEventBroker(soap, (const struct __tev__DeleteEventBroker *)ptr);
		break;
	case SOAP_TYPE___tev__AddEventBroker:
		soap_serialize___tev__AddEventBroker(soap, (const struct __tev__AddEventBroker *)ptr);
		break;
	case SOAP_TYPE___tev__GetEventProperties:
		soap_serialize___tev__GetEventProperties(soap, (const struct __tev__GetEventProperties *)ptr);
		break;
	case SOAP_TYPE___tev__CreatePullPointSubscription:
		soap_serialize___tev__CreatePullPointSubscription(soap, (const struct __tev__CreatePullPointSubscription *)ptr);
		break;
	case SOAP_TYPE___tev__GetServiceCapabilities:
		soap_serialize___tev__GetServiceCapabilities(soap, (const struct __tev__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tev__Unsubscribe:
		soap_serialize___tev__Unsubscribe(soap, (const struct __tev__Unsubscribe *)ptr);
		break;
	case SOAP_TYPE___tev__SetSynchronizationPoint:
		soap_serialize___tev__SetSynchronizationPoint(soap, (const struct __tev__SetSynchronizationPoint *)ptr);
		break;
	case SOAP_TYPE___tev__Seek:
		soap_serialize___tev__Seek(soap, (const struct __tev__Seek *)ptr);
		break;
	case SOAP_TYPE___tev__PullMessages:
		soap_serialize___tev__PullMessages(soap, (const struct __tev__PullMessages *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicType:
		soap_serialize_wstop__TopicType(soap, (const struct wstop__TopicType *)ptr);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, (const struct _wstop__TopicNamespaceType_Topic *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		soap_serialize_wstop__TopicNamespaceType(soap, (const struct wstop__TopicNamespaceType *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause:
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, (const struct _wsnt__ResumeFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_Description:
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, (const struct _wsnt__ResumeFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode:
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, (const struct _wsnt__ResumeFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__ResumeFailedFaultType:
		soap_serialize_wsnt__ResumeFailedFaultType(soap, (const struct wsnt__ResumeFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause:
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, (const struct _wsnt__PauseFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_Description:
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, (const struct _wsnt__PauseFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode:
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, (const struct _wsnt__PauseFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__PauseFailedFaultType:
		soap_serialize_wsnt__PauseFailedFaultType(soap, (const struct wsnt__PauseFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, (const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType:
		soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(soap, (const struct wsnt__UnableToDestroySubscriptionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, (const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType:
		soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(soap, (const struct wsnt__UnacceptableTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, (const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType:
		soap_serialize_wsnt__UnableToCreatePullPointFaultType(soap, (const struct wsnt__UnableToCreatePullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, (const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType:
		soap_serialize_wsnt__UnableToDestroyPullPointFaultType(soap, (const struct wsnt__UnableToDestroyPullPointFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, (const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, (const struct _wsnt__UnableToGetMessagesFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode:
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, (const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnableToGetMessagesFaultType:
		soap_serialize_wsnt__UnableToGetMessagesFaultType(soap, (const struct wsnt__UnableToGetMessagesFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, (const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType:
		soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(soap, (const struct wsnt__NoCurrentMessageOnTopicFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, (const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType:
		soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, (const struct wsnt__UnacceptableInitialTerminationTimeFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, (const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType:
		soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(soap, (const struct wsnt__NotifyMessageNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, (const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType:
		soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(soap, (const struct wsnt__UnsupportedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, (const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType:
		soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(soap, (const struct wsnt__UnrecognizedPolicyRequestFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType:
		soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(soap, (const struct wsnt__InvalidMessageContentExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType:
		soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, (const struct wsnt__InvalidProducerPropertiesExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, (const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType:
		soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(soap, (const struct wsnt__MultipleTopicsSpecifiedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause:
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, (const struct _wsnt__TopicNotSupportedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description:
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, (const struct _wsnt__TopicNotSupportedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode:
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, (const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicNotSupportedFaultType:
		soap_serialize_wsnt__TopicNotSupportedFaultType(soap, (const struct wsnt__TopicNotSupportedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, (const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType:
		soap_serialize_wsnt__InvalidTopicExpressionFaultType(soap, (const struct wsnt__InvalidTopicExpressionFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, (const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType:
		soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(soap, (const struct wsnt__TopicExpressionDialectUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause:
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, (const struct _wsnt__InvalidFilterFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_Description:
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, (const struct _wsnt__InvalidFilterFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode:
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, (const struct _wsnt__InvalidFilterFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__InvalidFilterFaultType:
		soap_serialize_wsnt__InvalidFilterFaultType(soap, (const struct wsnt__InvalidFilterFaultType *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, (const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType:
		soap_serialize_wsnt__SubscribeCreationFailedFaultType(soap, (const struct wsnt__SubscribeCreationFailedFaultType *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause:
		soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, (const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description:
		soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, (const struct _wsrfr__ResourceUnavailableFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode:
		soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, (const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnavailableFaultType:
		soap_serialize_wsrfr__ResourceUnavailableFaultType(soap, (const struct wsrfr__ResourceUnavailableFaultType *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause:
		soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(soap, (const struct _wsrfr__ResourceUnknownFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description:
		soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, (const struct _wsrfr__ResourceUnknownFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode:
		soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, (const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsrfr__ResourceUnknownFaultType:
		soap_serialize_wsrfr__ResourceUnknownFaultType(soap, (const struct wsrfr__ResourceUnknownFaultType *)ptr);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		soap_serialize_wstop__QueryExpressionType(soap, (const struct wstop__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		soap_serialize_wstop__ExtensibleDocumented(soap, (const struct wstop__ExtensibleDocumented *)ptr);
		break;
	case SOAP_TYPE_wstop__Documentation:
		soap_serialize_wstop__Documentation(soap, (const struct wstop__Documentation *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscriptionResponse:
		soap_serialize__wsnt__ResumeSubscriptionResponse(soap, (const struct _wsnt__ResumeSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__ResumeSubscription:
		soap_serialize__wsnt__ResumeSubscription(soap, (const struct _wsnt__ResumeSubscription *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseSubscriptionResponse:
		soap_serialize__wsnt__PauseSubscriptionResponse(soap, (const struct _wsnt__PauseSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__PauseSubscription:
		soap_serialize__wsnt__PauseSubscription(soap, (const struct _wsnt__PauseSubscription *)ptr);
		break;
	case SOAP_TYPE__wsnt__UnsubscribeResponse:
		soap_serialize__wsnt__UnsubscribeResponse(soap, (const struct _wsnt__UnsubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Unsubscribe:
		soap_serialize__wsnt__Unsubscribe(soap, (const struct _wsnt__Unsubscribe *)ptr);
		break;
	case SOAP_TYPE__wsnt__RenewResponse:
		soap_serialize__wsnt__RenewResponse(soap, (const struct _wsnt__RenewResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Renew:
		soap_serialize__wsnt__Renew(soap, (const struct _wsnt__Renew *)ptr);
		break;
	case SOAP_TYPE__wsnt__CreatePullPointResponse:
		soap_serialize__wsnt__CreatePullPointResponse(soap, (const struct _wsnt__CreatePullPointResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__CreatePullPoint:
		soap_serialize__wsnt__CreatePullPoint(soap, (const struct _wsnt__CreatePullPoint *)ptr);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPointResponse:
		soap_serialize__wsnt__DestroyPullPointResponse(soap, (const struct _wsnt__DestroyPullPointResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__DestroyPullPoint:
		soap_serialize__wsnt__DestroyPullPoint(soap, (const struct _wsnt__DestroyPullPoint *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetMessagesResponse:
		soap_serialize__wsnt__GetMessagesResponse(soap, (const struct _wsnt__GetMessagesResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetMessages:
		soap_serialize__wsnt__GetMessages(soap, (const struct _wsnt__GetMessages *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessageResponse:
		soap_serialize__wsnt__GetCurrentMessageResponse(soap, (const struct _wsnt__GetCurrentMessageResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__GetCurrentMessage:
		soap_serialize__wsnt__GetCurrentMessage(soap, (const struct _wsnt__GetCurrentMessage *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscribeResponse:
		soap_serialize__wsnt__SubscribeResponse(soap, (const struct _wsnt__SubscribeResponse *)ptr);
		break;
	case SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, (const struct _wsnt__Subscribe_SubscriptionPolicy *)ptr);
		break;
	case SOAP_TYPE__wsnt__Subscribe:
		soap_serialize__wsnt__Subscribe(soap, (const struct _wsnt__Subscribe *)ptr);
		break;
	case SOAP_TYPE__wsnt__UseRaw:
		soap_serialize__wsnt__UseRaw(soap, (const struct _wsnt__UseRaw *)ptr);
		break;
	case SOAP_TYPE__wsnt__Notify:
		soap_serialize__wsnt__Notify(soap, (const struct _wsnt__Notify *)ptr);
		break;
	case SOAP_TYPE__wsnt__SubscriptionManagerRP:
		soap_serialize__wsnt__SubscriptionManagerRP(soap, (const struct _wsnt__SubscriptionManagerRP *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotificationProducerRP:
		soap_serialize__wsnt__NotificationProducerRP(soap, (const struct _wsnt__NotificationProducerRP *)ptr);
		break;
	case SOAP_TYPE__wsnt__NotificationMessageHolderType_Message:
		soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, (const struct _wsnt__NotificationMessageHolderType_Message *)ptr);
		break;
	case SOAP_TYPE_wsnt__SubscriptionPolicyType:
		soap_serialize_wsnt__SubscriptionPolicyType(soap, (const struct wsnt__SubscriptionPolicyType *)ptr);
		break;
	case SOAP_TYPE_wsnt__TopicExpressionType:
		soap_serialize_wsnt__TopicExpressionType(soap, (const struct wsnt__TopicExpressionType *)ptr);
		break;
	case SOAP_TYPE_wsnt__QueryExpressionType:
		soap_serialize_wsnt__QueryExpressionType(soap, (const struct wsnt__QueryExpressionType *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, (const struct _wsrfbf__BaseFaultType_FaultCause *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, (const struct _wsrfbf__BaseFaultType_Description *)ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, (const struct _wsrfbf__BaseFaultType_ErrorCode *)ptr);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		soap_serialize_wsrfbf__BaseFaultType(soap, (const struct wsrfbf__BaseFaultType *)ptr);
		break;
	case SOAP_TYPE__tev__GetEventBrokersResponse:
		soap_serialize__tev__GetEventBrokersResponse(soap, (const struct _tev__GetEventBrokersResponse *)ptr);
		break;
	case SOAP_TYPE__tev__GetEventBrokers:
		soap_serialize__tev__GetEventBrokers(soap, (const struct _tev__GetEventBrokers *)ptr);
		break;
	case SOAP_TYPE__tev__DeleteEventBrokerResponse:
		soap_serialize__tev__DeleteEventBrokerResponse(soap, (const struct _tev__DeleteEventBrokerResponse *)ptr);
		break;
	case SOAP_TYPE__tev__DeleteEventBroker:
		soap_serialize__tev__DeleteEventBroker(soap, (const struct _tev__DeleteEventBroker *)ptr);
		break;
	case SOAP_TYPE__tev__AddEventBrokerResponse:
		soap_serialize__tev__AddEventBrokerResponse(soap, (const struct _tev__AddEventBrokerResponse *)ptr);
		break;
	case SOAP_TYPE__tev__AddEventBroker:
		soap_serialize__tev__AddEventBroker(soap, (const struct _tev__AddEventBroker *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		soap_serialize_wstop__TopicSetType(soap, (const struct wstop__TopicSetType *)ptr);
		break;
	case SOAP_TYPE__tev__GetEventPropertiesResponse:
		soap_serialize__tev__GetEventPropertiesResponse(soap, (const struct _tev__GetEventPropertiesResponse *)ptr);
		break;
	case SOAP_TYPE__tev__GetEventProperties:
		soap_serialize__tev__GetEventProperties(soap, (const struct _tev__GetEventProperties *)ptr);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPointResponse:
		soap_serialize__tev__SetSynchronizationPointResponse(soap, (const struct _tev__SetSynchronizationPointResponse *)ptr);
		break;
	case SOAP_TYPE__tev__SetSynchronizationPoint:
		soap_serialize__tev__SetSynchronizationPoint(soap, (const struct _tev__SetSynchronizationPoint *)ptr);
		break;
	case SOAP_TYPE__tev__SeekResponse:
		soap_serialize__tev__SeekResponse(soap, (const struct _tev__SeekResponse *)ptr);
		break;
	case SOAP_TYPE__tev__Seek:
		soap_serialize__tev__Seek(soap, (const struct _tev__Seek *)ptr);
		break;
	case SOAP_TYPE__tev__PullMessagesFaultResponse:
		soap_serialize__tev__PullMessagesFaultResponse(soap, (const struct _tev__PullMessagesFaultResponse *)ptr);
		break;
	case SOAP_TYPE_wsnt__NotificationMessageHolderType:
		soap_serialize_wsnt__NotificationMessageHolderType(soap, (const struct wsnt__NotificationMessageHolderType *)ptr);
		break;
	case SOAP_TYPE__tev__PullMessagesResponse:
		soap_serialize__tev__PullMessagesResponse(soap, (const struct _tev__PullMessagesResponse *)ptr);
		break;
	case SOAP_TYPE__tev__PullMessages:
		soap_serialize__tev__PullMessages(soap, (const struct _tev__PullMessages *)ptr);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscriptionResponse:
		soap_serialize__tev__CreatePullPointSubscriptionResponse(soap, (const struct _tev__CreatePullPointSubscriptionResponse *)ptr);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy:
		soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, (const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)ptr);
		break;
	case SOAP_TYPE__tev__CreatePullPointSubscription:
		soap_serialize__tev__CreatePullPointSubscription(soap, (const struct _tev__CreatePullPointSubscription *)ptr);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilitiesResponse:
		soap_serialize__tev__GetServiceCapabilitiesResponse(soap, (const struct _tev__GetServiceCapabilitiesResponse *)ptr);
		break;
	case SOAP_TYPE__tev__GetServiceCapabilities:
		soap_serialize__tev__GetServiceCapabilities(soap, (const struct _tev__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE_wsnt__FilterType:
		soap_serialize_wsnt__FilterType(soap, (const struct wsnt__FilterType *)ptr);
		break;
	case SOAP_TYPE_tev__EventBrokerConfig:
		soap_serialize_tev__EventBrokerConfig(soap, (const struct tev__EventBrokerConfig *)ptr);
		break;
	case SOAP_TYPE_tev__Capabilities:
		soap_serialize_tev__Capabilities(soap, (const struct tev__Capabilities *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscriptionResponse:
		soap_serialize_PointerTo_wsnt__ResumeSubscriptionResponse(soap, (struct _wsnt__ResumeSubscriptionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeSubscription:
		soap_serialize_PointerTo_wsnt__ResumeSubscription(soap, (struct _wsnt__ResumeSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscriptionResponse:
		soap_serialize_PointerTo_wsnt__PauseSubscriptionResponse(soap, (struct _wsnt__PauseSubscriptionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseSubscription:
		soap_serialize_PointerTo_wsnt__PauseSubscription(soap, (struct _wsnt__PauseSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPointResponse:
		soap_serialize_PointerTo_wsnt__CreatePullPointResponse(soap, (struct _wsnt__CreatePullPointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__CreatePullPoint:
		soap_serialize_PointerTo_wsnt__CreatePullPoint(soap, (struct _wsnt__CreatePullPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPointResponse:
		soap_serialize_PointerTo_wsnt__DestroyPullPointResponse(soap, (struct _wsnt__DestroyPullPointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint:
		soap_serialize_PointerTo_wsnt__DestroyPullPoint(soap, (struct _wsnt__DestroyPullPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetMessagesResponse:
		soap_serialize_PointerTo_wsnt__GetMessagesResponse(soap, (struct _wsnt__GetMessagesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetMessages:
		soap_serialize_PointerTo_wsnt__GetMessages(soap, (struct _wsnt__GetMessages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Notify:
		soap_serialize_PointerTo_wsnt__Notify(soap, (struct _wsnt__Notify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessageResponse:
		soap_serialize_PointerTo_wsnt__GetCurrentMessageResponse(soap, (struct _wsnt__GetCurrentMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage:
		soap_serialize_PointerTo_wsnt__GetCurrentMessage(soap, (struct _wsnt__GetCurrentMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeResponse:
		soap_serialize_PointerTo_wsnt__SubscribeResponse(soap, (struct _wsnt__SubscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe:
		soap_serialize_PointerTo_wsnt__Subscribe(soap, (struct _wsnt__Subscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__RenewResponse:
		soap_serialize_PointerTo_wsnt__RenewResponse(soap, (struct _wsnt__RenewResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Renew:
		soap_serialize_PointerTo_wsnt__Renew(soap, (struct _wsnt__Renew *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetEventBrokersResponse:
		soap_serialize_PointerTo_tev__GetEventBrokersResponse(soap, (struct _tev__GetEventBrokersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetEventBrokers:
		soap_serialize_PointerTo_tev__GetEventBrokers(soap, (struct _tev__GetEventBrokers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__DeleteEventBrokerResponse:
		soap_serialize_PointerTo_tev__DeleteEventBrokerResponse(soap, (struct _tev__DeleteEventBrokerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__DeleteEventBroker:
		soap_serialize_PointerTo_tev__DeleteEventBroker(soap, (struct _tev__DeleteEventBroker *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__AddEventBrokerResponse:
		soap_serialize_PointerTo_tev__AddEventBrokerResponse(soap, (struct _tev__AddEventBrokerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__AddEventBroker:
		soap_serialize_PointerTo_tev__AddEventBroker(soap, (struct _tev__AddEventBroker *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetEventPropertiesResponse:
		soap_serialize_PointerTo_tev__GetEventPropertiesResponse(soap, (struct _tev__GetEventPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetEventProperties:
		soap_serialize_PointerTo_tev__GetEventProperties(soap, (struct _tev__GetEventProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscriptionResponse:
		soap_serialize_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, (struct _tev__CreatePullPointSubscriptionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription:
		soap_serialize_PointerTo_tev__CreatePullPointSubscription(soap, (struct _tev__CreatePullPointSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilitiesResponse:
		soap_serialize_PointerTo_tev__GetServiceCapabilitiesResponse(soap, (struct _tev__GetServiceCapabilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__GetServiceCapabilities:
		soap_serialize_PointerTo_tev__GetServiceCapabilities(soap, (struct _tev__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsubscribeResponse:
		soap_serialize_PointerTo_wsnt__UnsubscribeResponse(soap, (struct _wsnt__UnsubscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Unsubscribe:
		soap_serialize_PointerTo_wsnt__Unsubscribe(soap, (struct _wsnt__Unsubscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPointResponse:
		soap_serialize_PointerTo_tev__SetSynchronizationPointResponse(soap, (struct _tev__SetSynchronizationPointResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint:
		soap_serialize_PointerTo_tev__SetSynchronizationPoint(soap, (struct _tev__SetSynchronizationPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__SeekResponse:
		soap_serialize_PointerTo_tev__SeekResponse(soap, (struct _tev__SeekResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__Seek:
		soap_serialize_PointerTo_tev__Seek(soap, (struct _tev__Seek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__PullMessagesResponse:
		soap_serialize_PointerTo_tev__PullMessagesResponse(soap, (struct _tev__PullMessagesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__PullMessages:
		soap_serialize_PointerTo_tev__PullMessages(soap, (struct _tev__PullMessages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType:
		soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, (struct wsnt__UnsupportedPolicyRequestFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType:
		soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, (struct wsnt__UnrecognizedPolicyRequestFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType:
		soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, (struct wsnt__UnacceptableTerminationTimeFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType:
		soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, (struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType:
		soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, (struct wsnt__UnableToGetMessagesFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType:
		soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, (struct wsnt__UnableToDestroySubscriptionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType:
		soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, (struct wsnt__UnableToDestroyPullPointFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType:
		soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, (struct wsnt__UnableToCreatePullPointFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType:
		soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, (struct wsnt__TopicNotSupportedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType:
		soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, (struct wsnt__TopicExpressionDialectUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType:
		soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, (struct wsnt__SubscribeCreationFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType:
		soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, (struct wsnt__ResumeFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType:
		soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, (struct wsrfr__ResourceUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse:
		soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, (struct _tev__PullMessagesFaultResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__PauseFailedFaultType:
		soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, (struct wsnt__PauseFailedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType:
		soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, (struct wsnt__NotifyMessageNotSupportedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType:
		soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, (struct wsnt__NoCurrentMessageOnTopicFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType:
		soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, (struct wsnt__MultipleTopicsSpecifiedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, (struct wsnt__InvalidTopicExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, (struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType:
		soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, (struct wsnt__InvalidMessageContentExpressionFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType:
		soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, (struct wsnt__InvalidFilterFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(soap, (struct _wstop__TopicNamespaceType_Topic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicType:
		soap_serialize_PointerTowstop__TopicType(soap, (struct wstop__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		soap_serialize_PointerTowstop__QueryExpressionType(soap, (struct wstop__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, (struct _wsnt__ResumeFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, (struct _wsnt__ResumeFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, (struct _wsnt__ResumeFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, (struct _wsnt__PauseFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(soap, (struct _wsnt__PauseFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, (struct _wsnt__PauseFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, (struct _wsnt__UnableToCreatePullPointFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, (struct _wsnt__UnableToGetMessagesFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, (struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, (struct _wsnt__TopicNotSupportedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, (struct _wsnt__InvalidTopicExpressionFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, (struct _wsnt__InvalidFilterFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, (struct _wsnt__InvalidFilterFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, (struct _wsnt__InvalidFilterFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, (struct _wsnt__SubscribeCreationFailedFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode:
		soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_Description:
		soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, (struct _wsrfr__ResourceUnavailableFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, (struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_Description:
		soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, (struct _wsrfr__ResourceUnknownFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__Documentation:
		soap_serialize_PointerTowstop__Documentation(soap, (struct wstop__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, (struct _wsnt__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType:
		soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, (struct wsnt__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__TopicExpressionType:
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, (struct wsnt__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, (struct _wsrfbf__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(soap, (struct _wsrfbf__BaseFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, (struct _wsrfbf__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotev__EventBrokerConfig:
		soap_serialize_PointerTotev__EventBrokerConfig(soap, (struct tev__EventBrokerConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		soap_serialize_PointerTowstop__TopicSetType(soap, (struct wstop__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, (struct wsnt__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy:
		soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotev__Capabilities:
		soap_serialize_PointerTotev__Capabilities(soap, (struct tev__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnt__FilterType:
		soap_serialize_PointerTowsnt__FilterType(soap, (struct wsnt__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *p;
	ULONG64 *a = (ULONG64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(ULONG64));
	for (p = a; p && n--; p++)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *p;
	time_t *a = (time_t*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(time_t));
	for (p = a; p && n--; p++)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tev__ConnectionStatus[] =
{	{ (LONG64)tev__ConnectionStatus__Offline, "Offline" },
	{ (LONG64)tev__ConnectionStatus__Connecting, "Connecting" },
	{ (LONG64)tev__ConnectionStatus__Connected, "Connected" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tev__ConnectionStatus2s(struct soap *soap, enum tev__ConnectionStatus n)
{
	const char *s = soap_code_str(soap_codes_tev__ConnectionStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__ConnectionStatus(struct soap *soap, const char *tag, int id, const enum tev__ConnectionStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__ConnectionStatus), type) || soap_send(soap, soap_tev__ConnectionStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tev__ConnectionStatus(struct soap *soap, const char *s, enum tev__ConnectionStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tev__ConnectionStatus, s);
	if (map)
		*a = (enum tev__ConnectionStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tev__ConnectionStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tev__ConnectionStatus * SOAP_FMAC4 soap_in_tev__ConnectionStatus(struct soap *soap, const char *tag, enum tev__ConnectionStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tev__ConnectionStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__ConnectionStatus, sizeof(enum tev__ConnectionStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tev__ConnectionStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tev__ConnectionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__ConnectionStatus, SOAP_TYPE_tev__ConnectionStatus, sizeof(enum tev__ConnectionStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tev__ConnectionStatus * SOAP_FMAC4 soap_new_tev__ConnectionStatus(struct soap *soap, int n)
{
	enum tev__ConnectionStatus *p;
	enum tev__ConnectionStatus *a = (enum tev__ConnectionStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tev__ConnectionStatus));
	for (p = a; p && n--; p++)
		soap_default_tev__ConnectionStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__ConnectionStatus(struct soap *soap, const enum tev__ConnectionStatus *a, const char *tag, const char *type)
{
	if (soap_out_tev__ConnectionStatus(soap, tag ? tag : "tev:ConnectionStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tev__ConnectionStatus * SOAP_FMAC4 soap_get_tev__ConnectionStatus(struct soap *soap, enum tev__ConnectionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__ConnectionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tev__EventBrokerProtocol[] =
{	{ (LONG64)tev__EventBrokerProtocol__mqtt, "mqtt" },
	{ (LONG64)tev__EventBrokerProtocol__mqtts, "mqtts" },
	{ (LONG64)tev__EventBrokerProtocol__ws, "ws" },
	{ (LONG64)tev__EventBrokerProtocol__wss, "wss" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tev__EventBrokerProtocol2s(struct soap *soap, enum tev__EventBrokerProtocol n)
{
	const char *s = soap_code_str(soap_codes_tev__EventBrokerProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__EventBrokerProtocol(struct soap *soap, const char *tag, int id, const enum tev__EventBrokerProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__EventBrokerProtocol), type) || soap_send(soap, soap_tev__EventBrokerProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tev__EventBrokerProtocol(struct soap *soap, const char *s, enum tev__EventBrokerProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tev__EventBrokerProtocol, s);
	if (map)
		*a = (enum tev__EventBrokerProtocol)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tev__EventBrokerProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tev__EventBrokerProtocol * SOAP_FMAC4 soap_in_tev__EventBrokerProtocol(struct soap *soap, const char *tag, enum tev__EventBrokerProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tev__EventBrokerProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__EventBrokerProtocol, sizeof(enum tev__EventBrokerProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tev__EventBrokerProtocol(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tev__EventBrokerProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__EventBrokerProtocol, SOAP_TYPE_tev__EventBrokerProtocol, sizeof(enum tev__EventBrokerProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tev__EventBrokerProtocol * SOAP_FMAC4 soap_new_tev__EventBrokerProtocol(struct soap *soap, int n)
{
	enum tev__EventBrokerProtocol *p;
	enum tev__EventBrokerProtocol *a = (enum tev__EventBrokerProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tev__EventBrokerProtocol));
	for (p = a; p && n--; p++)
		soap_default_tev__EventBrokerProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__EventBrokerProtocol(struct soap *soap, const enum tev__EventBrokerProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tev__EventBrokerProtocol(soap, tag ? tag : "tev:EventBrokerProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tev__EventBrokerProtocol * SOAP_FMAC4 soap_get_tev__EventBrokerProtocol(struct soap *soap, enum tev__EventBrokerProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__EventBrokerProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *p;
	enum _wsa5__IsReferenceParameter *a = (enum _wsa5__IsReferenceParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter));
	for (p = a; p && n--; p++)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *p;
	enum wsa5__FaultCodesType *a = (enum wsa5__FaultCodesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *p;
	enum wsa5__RelationshipType *a = (enum wsa5__RelationshipType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__ResumeSubscription(struct soap *soap, struct __tev__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__ResumeSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__ResumeSubscription(struct soap *soap, const struct __tev__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__ResumeSubscription(soap, &a->wsnt__ResumeSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct __tev__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", -1, &a->wsnt__ResumeSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__ResumeSubscription * SOAP_FMAC4 soap_in___tev__ResumeSubscription(struct soap *soap, const char *tag, struct __tev__ResumeSubscription *a, const char *type)
{
	size_t soap_flag_wsnt__ResumeSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__ResumeSubscription*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__ResumeSubscription, sizeof(struct __tev__ResumeSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__ResumeSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__ResumeSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeSubscription(soap, "wsnt:ResumeSubscription", &a->wsnt__ResumeSubscription, ""))
				{	soap_flag_wsnt__ResumeSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__ResumeSubscription * SOAP_FMAC4 soap_new___tev__ResumeSubscription(struct soap *soap, int n)
{
	struct __tev__ResumeSubscription *p;
	struct __tev__ResumeSubscription *a = (struct __tev__ResumeSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__ResumeSubscription));
	for (p = a; p && n--; p++)
		soap_default___tev__ResumeSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__ResumeSubscription(struct soap *soap, const struct __tev__ResumeSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__ResumeSubscription(soap, tag ? tag : "-tev:ResumeSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__ResumeSubscription * SOAP_FMAC4 soap_get___tev__ResumeSubscription(struct soap *soap, struct __tev__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__PauseSubscription(struct soap *soap, struct __tev__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__PauseSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__PauseSubscription(struct soap *soap, const struct __tev__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__PauseSubscription(soap, &a->wsnt__PauseSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__PauseSubscription(struct soap *soap, const char *tag, int id, const struct __tev__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", -1, &a->wsnt__PauseSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PauseSubscription * SOAP_FMAC4 soap_in___tev__PauseSubscription(struct soap *soap, const char *tag, struct __tev__PauseSubscription *a, const char *type)
{
	size_t soap_flag_wsnt__PauseSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__PauseSubscription*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__PauseSubscription, sizeof(struct __tev__PauseSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__PauseSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__PauseSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseSubscription(soap, "wsnt:PauseSubscription", &a->wsnt__PauseSubscription, ""))
				{	soap_flag_wsnt__PauseSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__PauseSubscription * SOAP_FMAC4 soap_new___tev__PauseSubscription(struct soap *soap, int n)
{
	struct __tev__PauseSubscription *p;
	struct __tev__PauseSubscription *a = (struct __tev__PauseSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__PauseSubscription));
	for (p = a; p && n--; p++)
		soap_default___tev__PauseSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__PauseSubscription(struct soap *soap, const struct __tev__PauseSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__PauseSubscription(soap, tag ? tag : "-tev:PauseSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PauseSubscription * SOAP_FMAC4 soap_get___tev__PauseSubscription(struct soap *soap, struct __tev__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe__(struct soap *soap, struct __tev__Unsubscribe__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe__(struct soap *soap, const struct __tev__Unsubscribe__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe__(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe__ * SOAP_FMAC4 soap_in___tev__Unsubscribe__(struct soap *soap, const char *tag, struct __tev__Unsubscribe__ *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe__*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe__, sizeof(struct __tev__Unsubscribe__), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Unsubscribe__ * SOAP_FMAC4 soap_new___tev__Unsubscribe__(struct soap *soap, int n)
{
	struct __tev__Unsubscribe__ *p;
	struct __tev__Unsubscribe__ *a = (struct __tev__Unsubscribe__*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Unsubscribe__));
	for (p = a; p && n--; p++)
		soap_default___tev__Unsubscribe__(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe__(struct soap *soap, const struct __tev__Unsubscribe__ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe__(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe__ * SOAP_FMAC4 soap_get___tev__Unsubscribe__(struct soap *soap, struct __tev__Unsubscribe__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Renew_(struct soap *soap, struct __tev__Renew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Renew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Renew_(struct soap *soap, const struct __tev__Renew_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Renew(soap, &a->wsnt__Renew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Renew_(struct soap *soap, const char *tag, int id, const struct __tev__Renew_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Renew(soap, "wsnt:Renew", -1, &a->wsnt__Renew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew_ * SOAP_FMAC4 soap_in___tev__Renew_(struct soap *soap, const char *tag, struct __tev__Renew_ *a, const char *type)
{
	size_t soap_flag_wsnt__Renew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Renew_*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Renew_, sizeof(struct __tev__Renew_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Renew_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Renew(soap, "wsnt:Renew", &a->wsnt__Renew, ""))
				{	soap_flag_wsnt__Renew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Renew_ * SOAP_FMAC4 soap_new___tev__Renew_(struct soap *soap, int n)
{
	struct __tev__Renew_ *p;
	struct __tev__Renew_ *a = (struct __tev__Renew_*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Renew_));
	for (p = a; p && n--; p++)
		soap_default___tev__Renew_(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Renew_(struct soap *soap, const struct __tev__Renew_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Renew_(soap, tag ? tag : "-tev:Renew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew_ * SOAP_FMAC4 soap_get___tev__Renew_(struct soap *soap, struct __tev__Renew_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Renew_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__CreatePullPoint(struct soap *soap, struct __tev__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__CreatePullPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__CreatePullPoint(struct soap *soap, const struct __tev__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__CreatePullPoint(soap, &a->wsnt__CreatePullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct __tev__CreatePullPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", -1, &a->wsnt__CreatePullPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPoint * SOAP_FMAC4 soap_in___tev__CreatePullPoint(struct soap *soap, const char *tag, struct __tev__CreatePullPoint *a, const char *type)
{
	size_t soap_flag_wsnt__CreatePullPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__CreatePullPoint*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__CreatePullPoint, sizeof(struct __tev__CreatePullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__CreatePullPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__CreatePullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__CreatePullPoint(soap, "wsnt:CreatePullPoint", &a->wsnt__CreatePullPoint, ""))
				{	soap_flag_wsnt__CreatePullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__CreatePullPoint * SOAP_FMAC4 soap_new___tev__CreatePullPoint(struct soap *soap, int n)
{
	struct __tev__CreatePullPoint *p;
	struct __tev__CreatePullPoint *a = (struct __tev__CreatePullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__CreatePullPoint));
	for (p = a; p && n--; p++)
		soap_default___tev__CreatePullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__CreatePullPoint(struct soap *soap, const struct __tev__CreatePullPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__CreatePullPoint(soap, tag ? tag : "-tev:CreatePullPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPoint * SOAP_FMAC4 soap_get___tev__CreatePullPoint(struct soap *soap, struct __tev__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Notify_(struct soap *soap, struct __tev__Notify_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Notify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Notify_(struct soap *soap, const struct __tev__Notify_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Notify(soap, &a->wsnt__Notify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Notify_(struct soap *soap, const char *tag, int id, const struct __tev__Notify_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Notify(soap, "wsnt:Notify", -1, &a->wsnt__Notify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify_ * SOAP_FMAC4 soap_in___tev__Notify_(struct soap *soap, const char *tag, struct __tev__Notify_ *a, const char *type)
{
	size_t soap_flag_wsnt__Notify = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Notify_*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Notify_, sizeof(struct __tev__Notify_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Notify_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Notify(soap, "wsnt:Notify", &a->wsnt__Notify, ""))
				{	soap_flag_wsnt__Notify--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Notify_ * SOAP_FMAC4 soap_new___tev__Notify_(struct soap *soap, int n)
{
	struct __tev__Notify_ *p;
	struct __tev__Notify_ *a = (struct __tev__Notify_*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Notify_));
	for (p = a; p && n--; p++)
		soap_default___tev__Notify_(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Notify_(struct soap *soap, const struct __tev__Notify_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Notify_(soap, tag ? tag : "-tev:Notify", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify_ * SOAP_FMAC4 soap_get___tev__Notify_(struct soap *soap, struct __tev__Notify_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Notify_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__DestroyPullPoint(struct soap *soap, struct __tev__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__DestroyPullPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__DestroyPullPoint(struct soap *soap, const struct __tev__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__DestroyPullPoint(soap, &a->wsnt__DestroyPullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct __tev__DestroyPullPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", -1, &a->wsnt__DestroyPullPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DestroyPullPoint * SOAP_FMAC4 soap_in___tev__DestroyPullPoint(struct soap *soap, const char *tag, struct __tev__DestroyPullPoint *a, const char *type)
{
	size_t soap_flag_wsnt__DestroyPullPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__DestroyPullPoint*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__DestroyPullPoint, sizeof(struct __tev__DestroyPullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__DestroyPullPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__DestroyPullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__DestroyPullPoint(soap, "wsnt:DestroyPullPoint", &a->wsnt__DestroyPullPoint, ""))
				{	soap_flag_wsnt__DestroyPullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__DestroyPullPoint * SOAP_FMAC4 soap_new___tev__DestroyPullPoint(struct soap *soap, int n)
{
	struct __tev__DestroyPullPoint *p;
	struct __tev__DestroyPullPoint *a = (struct __tev__DestroyPullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__DestroyPullPoint));
	for (p = a; p && n--; p++)
		soap_default___tev__DestroyPullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__DestroyPullPoint(struct soap *soap, const struct __tev__DestroyPullPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__DestroyPullPoint(soap, tag ? tag : "-tev:DestroyPullPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DestroyPullPoint * SOAP_FMAC4 soap_get___tev__DestroyPullPoint(struct soap *soap, struct __tev__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetMessages(struct soap *soap, struct __tev__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__GetMessages = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetMessages(struct soap *soap, const struct __tev__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__GetMessages(soap, &a->wsnt__GetMessages);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetMessages(struct soap *soap, const char *tag, int id, const struct __tev__GetMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__GetMessages(soap, "wsnt:GetMessages", -1, &a->wsnt__GetMessages, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetMessages * SOAP_FMAC4 soap_in___tev__GetMessages(struct soap *soap, const char *tag, struct __tev__GetMessages *a, const char *type)
{
	size_t soap_flag_wsnt__GetMessages = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetMessages*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetMessages, sizeof(struct __tev__GetMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetMessages(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__GetMessages && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__GetMessages(soap, "wsnt:GetMessages", &a->wsnt__GetMessages, ""))
				{	soap_flag_wsnt__GetMessages--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__GetMessages * SOAP_FMAC4 soap_new___tev__GetMessages(struct soap *soap, int n)
{
	struct __tev__GetMessages *p;
	struct __tev__GetMessages *a = (struct __tev__GetMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__GetMessages));
	for (p = a; p && n--; p++)
		soap_default___tev__GetMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetMessages(struct soap *soap, const struct __tev__GetMessages *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetMessages(soap, tag ? tag : "-tev:GetMessages", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetMessages * SOAP_FMAC4 soap_get___tev__GetMessages(struct soap *soap, struct __tev__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Notify(struct soap *soap, struct __tev__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Notify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Notify(struct soap *soap, const struct __tev__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Notify(soap, &a->wsnt__Notify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Notify(struct soap *soap, const char *tag, int id, const struct __tev__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Notify(soap, "wsnt:Notify", -1, &a->wsnt__Notify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify * SOAP_FMAC4 soap_in___tev__Notify(struct soap *soap, const char *tag, struct __tev__Notify *a, const char *type)
{
	size_t soap_flag_wsnt__Notify = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Notify*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Notify, sizeof(struct __tev__Notify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Notify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Notify && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Notify(soap, "wsnt:Notify", &a->wsnt__Notify, ""))
				{	soap_flag_wsnt__Notify--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Notify * SOAP_FMAC4 soap_new___tev__Notify(struct soap *soap, int n)
{
	struct __tev__Notify *p;
	struct __tev__Notify *a = (struct __tev__Notify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Notify));
	for (p = a; p && n--; p++)
		soap_default___tev__Notify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Notify(struct soap *soap, const struct __tev__Notify *a, const char *tag, const char *type)
{
	if (soap_out___tev__Notify(soap, tag ? tag : "-tev:Notify", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Notify * SOAP_FMAC4 soap_get___tev__Notify(struct soap *soap, struct __tev__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetCurrentMessage(struct soap *soap, struct __tev__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__GetCurrentMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetCurrentMessage(struct soap *soap, const struct __tev__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__GetCurrentMessage(soap, &a->wsnt__GetCurrentMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct __tev__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", -1, &a->wsnt__GetCurrentMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetCurrentMessage * SOAP_FMAC4 soap_in___tev__GetCurrentMessage(struct soap *soap, const char *tag, struct __tev__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_wsnt__GetCurrentMessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetCurrentMessage*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetCurrentMessage, sizeof(struct __tev__GetCurrentMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetCurrentMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__GetCurrentMessage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__GetCurrentMessage(soap, "wsnt:GetCurrentMessage", &a->wsnt__GetCurrentMessage, ""))
				{	soap_flag_wsnt__GetCurrentMessage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__GetCurrentMessage * SOAP_FMAC4 soap_new___tev__GetCurrentMessage(struct soap *soap, int n)
{
	struct __tev__GetCurrentMessage *p;
	struct __tev__GetCurrentMessage *a = (struct __tev__GetCurrentMessage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__GetCurrentMessage));
	for (p = a; p && n--; p++)
		soap_default___tev__GetCurrentMessage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetCurrentMessage(struct soap *soap, const struct __tev__GetCurrentMessage *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetCurrentMessage(soap, tag ? tag : "-tev:GetCurrentMessage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetCurrentMessage * SOAP_FMAC4 soap_get___tev__GetCurrentMessage(struct soap *soap, struct __tev__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Subscribe(struct soap *soap, struct __tev__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Subscribe(struct soap *soap, const struct __tev__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Subscribe(soap, &a->wsnt__Subscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Subscribe(struct soap *soap, const char *tag, int id, const struct __tev__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Subscribe(soap, "wsnt:Subscribe", -1, &a->wsnt__Subscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Subscribe * SOAP_FMAC4 soap_in___tev__Subscribe(struct soap *soap, const char *tag, struct __tev__Subscribe *a, const char *type)
{
	size_t soap_flag_wsnt__Subscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Subscribe*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Subscribe, sizeof(struct __tev__Subscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Subscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Subscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe(soap, "wsnt:Subscribe", &a->wsnt__Subscribe, ""))
				{	soap_flag_wsnt__Subscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Subscribe * SOAP_FMAC4 soap_new___tev__Subscribe(struct soap *soap, int n)
{
	struct __tev__Subscribe *p;
	struct __tev__Subscribe *a = (struct __tev__Subscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Subscribe));
	for (p = a; p && n--; p++)
		soap_default___tev__Subscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Subscribe(struct soap *soap, const struct __tev__Subscribe *a, const char *tag, const char *type)
{
	if (soap_out___tev__Subscribe(soap, tag ? tag : "-tev:Subscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Subscribe * SOAP_FMAC4 soap_get___tev__Subscribe(struct soap *soap, struct __tev__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe_(struct soap *soap, struct __tev__Unsubscribe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe_(struct soap *soap, const struct __tev__Unsubscribe_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe_(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe_ * SOAP_FMAC4 soap_in___tev__Unsubscribe_(struct soap *soap, const char *tag, struct __tev__Unsubscribe_ *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe_*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe_, sizeof(struct __tev__Unsubscribe_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Unsubscribe_ * SOAP_FMAC4 soap_new___tev__Unsubscribe_(struct soap *soap, int n)
{
	struct __tev__Unsubscribe_ *p;
	struct __tev__Unsubscribe_ *a = (struct __tev__Unsubscribe_*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Unsubscribe_));
	for (p = a; p && n--; p++)
		soap_default___tev__Unsubscribe_(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe_(struct soap *soap, const struct __tev__Unsubscribe_ *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe_(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe_ * SOAP_FMAC4 soap_get___tev__Unsubscribe_(struct soap *soap, struct __tev__Unsubscribe_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Renew(struct soap *soap, struct __tev__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Renew = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Renew(struct soap *soap, const struct __tev__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Renew(soap, &a->wsnt__Renew);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Renew(struct soap *soap, const char *tag, int id, const struct __tev__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Renew(soap, "wsnt:Renew", -1, &a->wsnt__Renew, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew * SOAP_FMAC4 soap_in___tev__Renew(struct soap *soap, const char *tag, struct __tev__Renew *a, const char *type)
{
	size_t soap_flag_wsnt__Renew = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Renew*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Renew, sizeof(struct __tev__Renew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Renew(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Renew && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Renew(soap, "wsnt:Renew", &a->wsnt__Renew, ""))
				{	soap_flag_wsnt__Renew--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Renew * SOAP_FMAC4 soap_new___tev__Renew(struct soap *soap, int n)
{
	struct __tev__Renew *p;
	struct __tev__Renew *a = (struct __tev__Renew*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Renew));
	for (p = a; p && n--; p++)
		soap_default___tev__Renew(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Renew(struct soap *soap, const struct __tev__Renew *a, const char *tag, const char *type)
{
	if (soap_out___tev__Renew(soap, tag ? tag : "-tev:Renew", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Renew * SOAP_FMAC4 soap_get___tev__Renew(struct soap *soap, struct __tev__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetEventBrokers(struct soap *soap, struct __tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__GetEventBrokers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetEventBrokers(struct soap *soap, const struct __tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__GetEventBrokers(soap, &a->tev__GetEventBrokers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetEventBrokers(struct soap *soap, const char *tag, int id, const struct __tev__GetEventBrokers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__GetEventBrokers(soap, "tev:GetEventBrokers", -1, &a->tev__GetEventBrokers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventBrokers * SOAP_FMAC4 soap_in___tev__GetEventBrokers(struct soap *soap, const char *tag, struct __tev__GetEventBrokers *a, const char *type)
{
	size_t soap_flag_tev__GetEventBrokers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetEventBrokers*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetEventBrokers, sizeof(struct __tev__GetEventBrokers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetEventBrokers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__GetEventBrokers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__GetEventBrokers(soap, "tev:GetEventBrokers", &a->tev__GetEventBrokers, ""))
				{	soap_flag_tev__GetEventBrokers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__GetEventBrokers * SOAP_FMAC4 soap_new___tev__GetEventBrokers(struct soap *soap, int n)
{
	struct __tev__GetEventBrokers *p;
	struct __tev__GetEventBrokers *a = (struct __tev__GetEventBrokers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__GetEventBrokers));
	for (p = a; p && n--; p++)
		soap_default___tev__GetEventBrokers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetEventBrokers(struct soap *soap, const struct __tev__GetEventBrokers *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetEventBrokers(soap, tag ? tag : "-tev:GetEventBrokers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventBrokers * SOAP_FMAC4 soap_get___tev__GetEventBrokers(struct soap *soap, struct __tev__GetEventBrokers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetEventBrokers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__DeleteEventBroker(struct soap *soap, struct __tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__DeleteEventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__DeleteEventBroker(struct soap *soap, const struct __tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__DeleteEventBroker(soap, &a->tev__DeleteEventBroker);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__DeleteEventBroker(struct soap *soap, const char *tag, int id, const struct __tev__DeleteEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__DeleteEventBroker(soap, "tev:DeleteEventBroker", -1, &a->tev__DeleteEventBroker, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DeleteEventBroker * SOAP_FMAC4 soap_in___tev__DeleteEventBroker(struct soap *soap, const char *tag, struct __tev__DeleteEventBroker *a, const char *type)
{
	size_t soap_flag_tev__DeleteEventBroker = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__DeleteEventBroker*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__DeleteEventBroker, sizeof(struct __tev__DeleteEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__DeleteEventBroker(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__DeleteEventBroker && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__DeleteEventBroker(soap, "tev:DeleteEventBroker", &a->tev__DeleteEventBroker, ""))
				{	soap_flag_tev__DeleteEventBroker--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__DeleteEventBroker * SOAP_FMAC4 soap_new___tev__DeleteEventBroker(struct soap *soap, int n)
{
	struct __tev__DeleteEventBroker *p;
	struct __tev__DeleteEventBroker *a = (struct __tev__DeleteEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__DeleteEventBroker));
	for (p = a; p && n--; p++)
		soap_default___tev__DeleteEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__DeleteEventBroker(struct soap *soap, const struct __tev__DeleteEventBroker *a, const char *tag, const char *type)
{
	if (soap_out___tev__DeleteEventBroker(soap, tag ? tag : "-tev:DeleteEventBroker", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__DeleteEventBroker * SOAP_FMAC4 soap_get___tev__DeleteEventBroker(struct soap *soap, struct __tev__DeleteEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__DeleteEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__AddEventBroker(struct soap *soap, struct __tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__AddEventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__AddEventBroker(struct soap *soap, const struct __tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__AddEventBroker(soap, &a->tev__AddEventBroker);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__AddEventBroker(struct soap *soap, const char *tag, int id, const struct __tev__AddEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__AddEventBroker(soap, "tev:AddEventBroker", -1, &a->tev__AddEventBroker, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__AddEventBroker * SOAP_FMAC4 soap_in___tev__AddEventBroker(struct soap *soap, const char *tag, struct __tev__AddEventBroker *a, const char *type)
{
	size_t soap_flag_tev__AddEventBroker = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__AddEventBroker*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__AddEventBroker, sizeof(struct __tev__AddEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__AddEventBroker(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__AddEventBroker && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__AddEventBroker(soap, "tev:AddEventBroker", &a->tev__AddEventBroker, ""))
				{	soap_flag_tev__AddEventBroker--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__AddEventBroker * SOAP_FMAC4 soap_new___tev__AddEventBroker(struct soap *soap, int n)
{
	struct __tev__AddEventBroker *p;
	struct __tev__AddEventBroker *a = (struct __tev__AddEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__AddEventBroker));
	for (p = a; p && n--; p++)
		soap_default___tev__AddEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__AddEventBroker(struct soap *soap, const struct __tev__AddEventBroker *a, const char *tag, const char *type)
{
	if (soap_out___tev__AddEventBroker(soap, tag ? tag : "-tev:AddEventBroker", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__AddEventBroker * SOAP_FMAC4 soap_get___tev__AddEventBroker(struct soap *soap, struct __tev__AddEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__AddEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetEventProperties(struct soap *soap, struct __tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__GetEventProperties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetEventProperties(struct soap *soap, const struct __tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__GetEventProperties(soap, &a->tev__GetEventProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetEventProperties(struct soap *soap, const char *tag, int id, const struct __tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__GetEventProperties(soap, "tev:GetEventProperties", -1, &a->tev__GetEventProperties, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventProperties * SOAP_FMAC4 soap_in___tev__GetEventProperties(struct soap *soap, const char *tag, struct __tev__GetEventProperties *a, const char *type)
{
	size_t soap_flag_tev__GetEventProperties = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetEventProperties*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetEventProperties, sizeof(struct __tev__GetEventProperties), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetEventProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__GetEventProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__GetEventProperties(soap, "tev:GetEventProperties", &a->tev__GetEventProperties, ""))
				{	soap_flag_tev__GetEventProperties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__GetEventProperties * SOAP_FMAC4 soap_new___tev__GetEventProperties(struct soap *soap, int n)
{
	struct __tev__GetEventProperties *p;
	struct __tev__GetEventProperties *a = (struct __tev__GetEventProperties*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__GetEventProperties));
	for (p = a; p && n--; p++)
		soap_default___tev__GetEventProperties(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetEventProperties(struct soap *soap, const struct __tev__GetEventProperties *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetEventProperties(soap, tag ? tag : "-tev:GetEventProperties", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetEventProperties * SOAP_FMAC4 soap_get___tev__GetEventProperties(struct soap *soap, struct __tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__CreatePullPointSubscription(struct soap *soap, struct __tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__CreatePullPointSubscription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__CreatePullPointSubscription(struct soap *soap, const struct __tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__CreatePullPointSubscription(soap, &a->tev__CreatePullPointSubscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct __tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__CreatePullPointSubscription(soap, "tev:CreatePullPointSubscription", -1, &a->tev__CreatePullPointSubscription, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in___tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct __tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_tev__CreatePullPointSubscription = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__CreatePullPointSubscription*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__CreatePullPointSubscription, sizeof(struct __tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__CreatePullPointSubscription(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__CreatePullPointSubscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription(soap, "tev:CreatePullPointSubscription", &a->tev__CreatePullPointSubscription, ""))
				{	soap_flag_tev__CreatePullPointSubscription--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__CreatePullPointSubscription * SOAP_FMAC4 soap_new___tev__CreatePullPointSubscription(struct soap *soap, int n)
{
	struct __tev__CreatePullPointSubscription *p;
	struct __tev__CreatePullPointSubscription *a = (struct __tev__CreatePullPointSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__CreatePullPointSubscription));
	for (p = a; p && n--; p++)
		soap_default___tev__CreatePullPointSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__CreatePullPointSubscription(struct soap *soap, const struct __tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	if (soap_out___tev__CreatePullPointSubscription(soap, tag ? tag : "-tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get___tev__CreatePullPointSubscription(struct soap *soap, struct __tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__GetServiceCapabilities(struct soap *soap, struct __tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__GetServiceCapabilities(struct soap *soap, const struct __tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__GetServiceCapabilities(soap, &a->tev__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__GetServiceCapabilities(soap, "tev:GetServiceCapabilities", -1, &a->tev__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetServiceCapabilities * SOAP_FMAC4 soap_in___tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tev__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tev__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__GetServiceCapabilities, sizeof(struct __tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__GetServiceCapabilities(soap, "tev:GetServiceCapabilities", &a->tev__GetServiceCapabilities, ""))
				{	soap_flag_tev__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__GetServiceCapabilities * SOAP_FMAC4 soap_new___tev__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tev__GetServiceCapabilities *p;
	struct __tev__GetServiceCapabilities *a = (struct __tev__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tev__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__GetServiceCapabilities(struct soap *soap, const struct __tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tev__GetServiceCapabilities(soap, tag ? tag : "-tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__GetServiceCapabilities * SOAP_FMAC4 soap_get___tev__GetServiceCapabilities(struct soap *soap, struct __tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Unsubscribe(struct soap *soap, struct __tev__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__Unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Unsubscribe(struct soap *soap, const struct __tev__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsnt__Unsubscribe(soap, &a->wsnt__Unsubscribe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Unsubscribe(struct soap *soap, const char *tag, int id, const struct __tev__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", -1, &a->wsnt__Unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe * SOAP_FMAC4 soap_in___tev__Unsubscribe(struct soap *soap, const char *tag, struct __tev__Unsubscribe *a, const char *type)
{
	size_t soap_flag_wsnt__Unsubscribe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Unsubscribe*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Unsubscribe, sizeof(struct __tev__Unsubscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Unsubscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__Unsubscribe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Unsubscribe(soap, "wsnt:Unsubscribe", &a->wsnt__Unsubscribe, ""))
				{	soap_flag_wsnt__Unsubscribe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Unsubscribe * SOAP_FMAC4 soap_new___tev__Unsubscribe(struct soap *soap, int n)
{
	struct __tev__Unsubscribe *p;
	struct __tev__Unsubscribe *a = (struct __tev__Unsubscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Unsubscribe));
	for (p = a; p && n--; p++)
		soap_default___tev__Unsubscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Unsubscribe(struct soap *soap, const struct __tev__Unsubscribe *a, const char *tag, const char *type)
{
	if (soap_out___tev__Unsubscribe(soap, tag ? tag : "-tev:Unsubscribe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Unsubscribe * SOAP_FMAC4 soap_get___tev__Unsubscribe(struct soap *soap, struct __tev__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__SetSynchronizationPoint(struct soap *soap, struct __tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__SetSynchronizationPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__SetSynchronizationPoint(struct soap *soap, const struct __tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__SetSynchronizationPoint(soap, &a->tev__SetSynchronizationPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct __tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__SetSynchronizationPoint(soap, "tev:SetSynchronizationPoint", -1, &a->tev__SetSynchronizationPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in___tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct __tev__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_tev__SetSynchronizationPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__SetSynchronizationPoint*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__SetSynchronizationPoint, sizeof(struct __tev__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__SetSynchronizationPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__SetSynchronizationPoint(soap, "tev:SetSynchronizationPoint", &a->tev__SetSynchronizationPoint, ""))
				{	soap_flag_tev__SetSynchronizationPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__SetSynchronizationPoint * SOAP_FMAC4 soap_new___tev__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct __tev__SetSynchronizationPoint *p;
	struct __tev__SetSynchronizationPoint *a = (struct __tev__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default___tev__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__SetSynchronizationPoint(struct soap *soap, const struct __tev__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out___tev__SetSynchronizationPoint(soap, tag ? tag : "-tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get___tev__SetSynchronizationPoint(struct soap *soap, struct __tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__Seek(struct soap *soap, struct __tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__Seek = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__Seek(struct soap *soap, const struct __tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__Seek(soap, &a->tev__Seek);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__Seek(struct soap *soap, const char *tag, int id, const struct __tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__Seek(soap, "tev:Seek", -1, &a->tev__Seek, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Seek * SOAP_FMAC4 soap_in___tev__Seek(struct soap *soap, const char *tag, struct __tev__Seek *a, const char *type)
{
	size_t soap_flag_tev__Seek = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__Seek*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__Seek, sizeof(struct __tev__Seek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__Seek(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__Seek && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__Seek(soap, "tev:Seek", &a->tev__Seek, ""))
				{	soap_flag_tev__Seek--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__Seek * SOAP_FMAC4 soap_new___tev__Seek(struct soap *soap, int n)
{
	struct __tev__Seek *p;
	struct __tev__Seek *a = (struct __tev__Seek*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__Seek));
	for (p = a; p && n--; p++)
		soap_default___tev__Seek(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__Seek(struct soap *soap, const struct __tev__Seek *a, const char *tag, const char *type)
{
	if (soap_out___tev__Seek(soap, tag ? tag : "-tev:Seek", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__Seek * SOAP_FMAC4 soap_get___tev__Seek(struct soap *soap, struct __tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tev__PullMessages(struct soap *soap, struct __tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tev__PullMessages = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tev__PullMessages(struct soap *soap, const struct __tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tev__PullMessages(soap, &a->tev__PullMessages);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tev__PullMessages(struct soap *soap, const char *tag, int id, const struct __tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tev__PullMessages(soap, "tev:PullMessages", -1, &a->tev__PullMessages, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PullMessages * SOAP_FMAC4 soap_in___tev__PullMessages(struct soap *soap, const char *tag, struct __tev__PullMessages *a, const char *type)
{
	size_t soap_flag_tev__PullMessages = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tev__PullMessages*)soap_id_enter(soap, "", a, SOAP_TYPE___tev__PullMessages, sizeof(struct __tev__PullMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tev__PullMessages(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tev__PullMessages && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__PullMessages(soap, "tev:PullMessages", &a->tev__PullMessages, ""))
				{	soap_flag_tev__PullMessages--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tev__PullMessages * SOAP_FMAC4 soap_new___tev__PullMessages(struct soap *soap, int n)
{
	struct __tev__PullMessages *p;
	struct __tev__PullMessages *a = (struct __tev__PullMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tev__PullMessages));
	for (p = a; p && n--; p++)
		soap_default___tev__PullMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tev__PullMessages(struct soap *soap, const struct __tev__PullMessages *a, const char *tag, const char *type)
{
	if (soap_out___tev__PullMessages(soap, tag ? tag : "-tev:PullMessages", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tev__PullMessages * SOAP_FMAC4 soap_get___tev__PullMessages(struct soap *soap, struct __tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in___tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicType(struct soap *soap, struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const struct wstop__TopicType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_new_wstop__TopicType(struct soap *soap, int n)
{
	struct wstop__TopicType *p;
	struct wstop__TopicType *a = (struct wstop__TopicType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, struct wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
	soap_default_wstop__ConcreteTopicExpression(soap, &a->parent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	if (a->parent)
		soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, a->parent), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wstop__TopicNamespaceType_Topic*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wstop__TopicNamespaceType_Topic(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap_s2wstop__ConcreteTopicExpression(soap, soap_attr_value(soap, "parent", 5, 0), &a->parent))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_new__wstop__TopicNamespaceType_Topic(struct soap *soap, int n)
{
	struct _wstop__TopicNamespaceType_Topic *p;
	struct _wstop__TopicNamespaceType_Topic *a = (struct _wstop__TopicNamespaceType_Topic*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wstop__TopicNamespaceType_Topic));
	for (p = a; p && n--; p++)
		soap_default__wstop__TopicNamespaceType_Topic(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a, const char *tag, const char *type)
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyURI(soap, &a->targetNamespace);
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
			soap_serialize__wstop__TopicNamespaceType_Topic(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const struct wstop__TopicNamespaceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	soap_set_attr(soap, "targetNamespace", a->targetNamespace ? soap_xsd__anyURI2s(soap, a->targetNamespace) : "", 1);
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, struct wstop__TopicNamespaceType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicNamespaceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicNamespaceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &a->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &a->targetNamespace))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic));
					if (a->Topic == NULL)
						return NULL;
					soap_default__wstop__TopicNamespaceType_Topic(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", a->Topic, ""))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_new_wstop__TopicNamespaceType(struct soap *soap, int n)
{
	struct wstop__TopicNamespaceType *p;
	struct wstop__TopicNamespaceType *a = (struct wstop__TopicNamespaceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicNamespaceType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicNamespaceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_FaultCause *p;
	struct _wsnt__ResumeFailedFaultType_FaultCause *a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__ResumeFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__ResumeFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_Description *p;
	struct _wsnt__ResumeFailedFaultType_Description *a = (struct _wsnt__ResumeFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_ErrorCode *p;
	struct _wsnt__ResumeFailedFaultType_ErrorCode *a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
			soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__ResumeFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__ResumeFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_new_wsnt__ResumeFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__ResumeFailedFaultType *p;
	struct wsnt__ResumeFailedFaultType *a = (struct wsnt__ResumeFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__ResumeFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__ResumeFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_FaultCause *p;
	struct _wsnt__PauseFailedFaultType_FaultCause *a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__PauseFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__PauseFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_Description *p;
	struct _wsnt__PauseFailedFaultType_Description *a = (struct _wsnt__PauseFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_ErrorCode *p;
	struct _wsnt__PauseFailedFaultType_ErrorCode *a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
			soap_serialize__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__PauseFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__PauseFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__PauseFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__PauseFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_new_wsnt__PauseFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__PauseFailedFaultType *p;
	struct wsnt__PauseFailedFaultType *a = (struct wsnt__PauseFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__PauseFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__PauseFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
			soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroySubscriptionFaultType *p;
	struct wsnt__UnableToDestroySubscriptionFaultType *a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroySubscriptionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableTerminationTimeFaultType *p;
	struct wsnt__UnacceptableTerminationTimeFaultType *a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_Description *p;
	struct _wsnt__UnableToCreatePullPointFaultType_Description *a = (struct _wsnt__UnableToCreatePullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
			soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToCreatePullPointFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToCreatePullPointFaultType *p;
	struct wsnt__UnableToCreatePullPointFaultType *a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToCreatePullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToCreatePullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description);
			soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroyPullPointFaultType *p;
	struct wsnt__UnableToDestroyPullPointFaultType *a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroyPullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p;
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_Description *p;
	struct _wsnt__UnableToGetMessagesFaultType_Description *a = (struct _wsnt__UnableToGetMessagesFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p;
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description);
			soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToGetMessagesFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToGetMessagesFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToGetMessagesFaultType *p;
	struct wsnt__UnableToGetMessagesFaultType *a = (struct wsnt__UnableToGetMessagesFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToGetMessagesFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToGetMessagesFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description);
			soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n)
{
	struct wsnt__NoCurrentMessageOnTopicFaultType *p;
	struct wsnt__NoCurrentMessageOnTopicFaultType *a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description);
			soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__NotifyMessageNotSupportedFaultType *p;
	struct wsnt__NotifyMessageNotSupportedFaultType *a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotifyMessageNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnsupportedPolicy = 0;
	a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnsupportedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{	const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnsupportedPolicy", -1, (char*const*)(void*)&soap_tmp_UnsupportedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnsupportedPolicy", 1, NULL))
			{	if (a->UnsupportedPolicy == NULL)
				{	if (soap_blist_UnsupportedPolicy == NULL)
						soap_blist_UnsupportedPolicy = soap_alloc_block(soap);
					a->UnsupportedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
					if (a->UnsupportedPolicy == NULL)
						return NULL;
					*a->UnsupportedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnsupportedPolicy", (char**)a->UnsupportedPolicy, "xsd:QName"))
				{	a->__sizeUnsupportedPolicy++;
					a->UnsupportedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnsupportedPolicy)
			soap_pop_block(soap, soap_blist_UnsupportedPolicy);
		if (a->__sizeUnsupportedPolicy)
		{	a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
		}
		else
		{	a->UnsupportedPolicy = NULL;
			if (soap_blist_UnsupportedPolicy)
				soap_end_block(soap, soap_blist_UnsupportedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnsupportedPolicyRequestFaultType *p;
	struct wsnt__UnsupportedPolicyRequestFaultType *a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnsupportedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnrecognizedPolicy = 0;
	a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnrecognizedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{	const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnrecognizedPolicy", -1, (char*const*)(void*)&soap_tmp_UnrecognizedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnrecognizedPolicy", 1, NULL))
			{	if (a->UnrecognizedPolicy == NULL)
				{	if (soap_blist_UnrecognizedPolicy == NULL)
						soap_blist_UnrecognizedPolicy = soap_alloc_block(soap);
					a->UnrecognizedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
					if (a->UnrecognizedPolicy == NULL)
						return NULL;
					*a->UnrecognizedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnrecognizedPolicy", (char**)a->UnrecognizedPolicy, "xsd:QName"))
				{	a->__sizeUnrecognizedPolicy++;
					a->UnrecognizedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnrecognizedPolicy)
			soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
		if (a->__sizeUnrecognizedPolicy)
		{	a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
		}
		else
		{	a->UnrecognizedPolicy = NULL;
			if (soap_blist_UnrecognizedPolicy)
				soap_end_block(soap, soap_blist_UnrecognizedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnrecognizedPolicyRequestFaultType *p;
	struct wsnt__UnrecognizedPolicyRequestFaultType *a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidMessageContentExpressionFaultType *p;
	struct wsnt__InvalidMessageContentExpressionFaultType *a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidMessageContentExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
			soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n)
{
	struct wsnt__MultipleTopicsSpecifiedFaultType *p;
	struct wsnt__MultipleTopicsSpecifiedFaultType *a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *p;
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_Description *p;
	struct _wsnt__TopicNotSupportedFaultType_Description *a = (struct _wsnt__TopicNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
			soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicNotSupportedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicNotSupportedFaultType *p;
	struct wsnt__TopicNotSupportedFaultType *a = (struct wsnt__TopicNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_Description *p;
	struct _wsnt__InvalidTopicExpressionFaultType_Description *a = (struct _wsnt__InvalidTopicExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidTopicExpressionFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidTopicExpressionFaultType *p;
	struct wsnt__InvalidTopicExpressionFaultType *a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidTopicExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidTopicExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionDialectUnknownFaultType *p;
	struct wsnt__TopicExpressionDialectUnknownFaultType *a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_FaultCause *p;
	struct _wsnt__InvalidFilterFaultType_FaultCause *a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_Description *p;
	struct _wsnt__InvalidFilterFaultType_Description *a = (struct _wsnt__InvalidFilterFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_ErrorCode *p;
	struct _wsnt__InvalidFilterFaultType_ErrorCode *a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnknownFilter + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)(void*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_alloc_block(soap);
					a->UnknownFilter = (char **)soap_push_block_max(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", (char**)a->UnknownFilter, "xsd:QName"))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
		{	a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		}
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidFilterFaultType *p;
	struct wsnt__InvalidFilterFaultType *a = (struct wsnt__InvalidFilterFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidFilterFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidFilterFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p;
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_Description *p;
	struct _wsnt__SubscribeCreationFailedFaultType_Description *a = (struct _wsnt__SubscribeCreationFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p;
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__SubscribeCreationFailedFaultType *p;
	struct wsnt__SubscribeCreationFailedFaultType *a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscribeCreationFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscribeCreationFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_Description *p;
	struct _wsrfr__ResourceUnavailableFaultType_Description *a = (struct _wsrfr__ResourceUnavailableFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description);
			soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfr__ResourceUnavailableFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnavailableFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnavailableFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnavailableFaultType *p;
	struct wsrfr__ResourceUnavailableFaultType *a = (struct wsrfr__ResourceUnavailableFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnavailableFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnavailableFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_Description *p;
	struct _wsrfr__ResourceUnknownFaultType_Description *a = (struct _wsrfr__ResourceUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description);
			soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfr__ResourceUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnknownFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnknownFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnknownFaultType *p;
	struct wsrfr__ResourceUnknownFaultType *a = (struct wsrfr__ResourceUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_new_wstop__QueryExpressionType(struct soap *soap, int n)
{
	struct wstop__QueryExpressionType *p;
	struct wstop__QueryExpressionType *a = (struct wstop__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wstop__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const struct wstop__ExtensibleDocumented *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, struct wstop__ExtensibleDocumented *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__ExtensibleDocumented*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__ExtensibleDocumented(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_new_wstop__ExtensibleDocumented(struct soap *soap, int n)
{
	struct wstop__ExtensibleDocumented *p;
	struct wstop__ExtensibleDocumented *a = (struct wstop__ExtensibleDocumented*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__ExtensibleDocumented));
	for (p = a; p && n--; p++)
		soap_default_wstop__ExtensibleDocumented(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a, const char *tag, const char *type)
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__Documentation(struct soap *soap, struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const struct wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__Documentation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__Documentation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_new_wstop__Documentation(struct soap *soap, int n)
{
	struct wstop__Documentation *p;
	struct wstop__Documentation *a = (struct wstop__Documentation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__Documentation));
	for (p = a; p && n--; p++)
		soap_default_wstop__Documentation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a, const char *tag, const char *type)
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, struct wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscriptionResponse *p;
	struct _wsnt__ResumeSubscriptionResponse *a = (struct _wsnt__ResumeSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_new__wsnt__ResumeSubscription(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscription *p;
	struct _wsnt__ResumeSubscription *a = (struct _wsnt__ResumeSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__PauseSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscriptionResponse *p;
	struct _wsnt__PauseSubscriptionResponse *a = (struct _wsnt__PauseSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_new__wsnt__PauseSubscription(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscription *p;
	struct _wsnt__PauseSubscription *a = (struct _wsnt__PauseSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_new__wsnt__UnsubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__UnsubscribeResponse *p;
	struct _wsnt__UnsubscribeResponse *a = (struct _wsnt__UnsubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Unsubscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Unsubscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_new__wsnt__Unsubscribe(struct soap *soap, int n)
{
	struct _wsnt__Unsubscribe *p;
	struct _wsnt__Unsubscribe *a = (struct _wsnt__Unsubscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Unsubscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Unsubscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->TerminationTime);
	a->CurrentTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:TerminationTime");
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_CurrentTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__RenewResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__RenewResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:TerminationTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_new__wsnt__RenewResponse(struct soap *soap, int n)
{
	struct _wsnt__RenewResponse *p;
	struct _wsnt__RenewResponse *a = (struct _wsnt__RenewResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__RenewResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__RenewResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->TerminationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const struct _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, (char*const*)&a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Renew*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Renew(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", (char**)&a->TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_new__wsnt__Renew(struct soap *soap, int n)
{
	struct _wsnt__Renew *p;
	struct _wsnt__Renew *a = (struct _wsnt__Renew*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Renew));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Renew(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:PullPoint");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->PullPoint, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	size_t soap_flag_PullPoint = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPointResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:PullPoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_new__wsnt__CreatePullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPointResponse *p;
	struct _wsnt__CreatePullPointResponse *a = (struct _wsnt__CreatePullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPoint(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_new__wsnt__CreatePullPoint(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPoint *p;
	struct _wsnt__CreatePullPoint *a = (struct _wsnt__CreatePullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPointResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_new__wsnt__DestroyPullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPointResponse *p;
	struct _wsnt__DestroyPullPointResponse *a = (struct _wsnt__DestroyPullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPoint(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_new__wsnt__DestroyPullPoint(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPoint *p;
	struct _wsnt__DestroyPullPoint *a = (struct _wsnt__DestroyPullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessagesResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNotificationMessage");
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessagesResponse(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNotificationMessage");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_new__wsnt__GetMessagesResponse(struct soap *soap, int n)
{
	struct _wsnt__GetMessagesResponse *p;
	struct _wsnt__GetMessagesResponse *a = (struct _wsnt__GetMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &a->MaximumNumber);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__nonNegativeInteger(soap, (char*const*)&a->MaximumNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessages *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, (char*const*)&a->MaximumNumber, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages *a, const char *type)
{
	size_t soap_flag_MaximumNumber = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessages(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", (char**)&a->MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_new__wsnt__GetMessages(struct soap *soap, int n)
{
	struct _wsnt__GetMessages *p;
	struct _wsnt__GetMessages *a = (struct _wsnt__GetMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessages));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessageResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessageResponse(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessageResponse *p;
	struct _wsnt__GetCurrentMessageResponse *a = (struct _wsnt__GetCurrentMessageResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessageResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessageResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (!a->Topic)
	{	if (soap_element_empty(soap, "wsnt:Topic", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_Topic = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessage(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessage(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessage *p;
	struct _wsnt__GetCurrentMessage *a = (struct _wsnt__GetCurrentMessage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessage));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->CurrentTime = NULL;
	a->TerminationTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
	soap_serialize_PointerTodateTime(soap, &a->TerminationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_new__wsnt__SubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__SubscribeResponse *p;
	struct _wsnt__SubscribeResponse *a = (struct _wsnt__SubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _wsnt__Subscribe_SubscriptionPolicy *p;
	struct _wsnt__Subscribe_SubscriptionPolicy *a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_new__wsnt__Subscribe(struct soap *soap, int n)
{
	struct _wsnt__Subscribe *p;
	struct _wsnt__Subscribe *a = (struct _wsnt__Subscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const struct _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, struct _wsnt__UseRaw *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UseRaw*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UseRaw(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_new__wsnt__UseRaw(struct soap *soap, int n)
{
	struct _wsnt__UseRaw *p;
	struct _wsnt__UseRaw *a = (struct _wsnt__UseRaw*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UseRaw));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UseRaw(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const struct _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Notify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Notify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_new__wsnt__Notify(struct soap *soap, int n)
{
	struct _wsnt__Notify *p;
	struct _wsnt__Notify *a = (struct _wsnt__Notify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Notify));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Notify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &a->CreationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CreationTime", -1, &a->CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	size_t soap_flag_CreationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscriptionManagerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscriptionManagerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CreationTime", &a->CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_new__wsnt__SubscriptionManagerRP(struct soap *soap, int n)
{
	struct _wsnt__SubscriptionManagerRP *p;
	struct _wsnt__SubscriptionManagerRP *a = (struct _wsnt__SubscriptionManagerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscriptionManagerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscriptionManagerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicExpression = 0;
	a->TopicExpression_ = NULL;
	a->FixedTopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->TopicExpressionDialect_ = NULL;
	a->wstop__TopicSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
		{
			soap_embedded(soap, a->TopicExpression_ + i, SOAP_TYPE_wsnt__TopicExpressionType);
			soap_serialize_wsnt__TopicExpressionType(soap, a->TopicExpression_ + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->FixedTopicSet);
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->TopicExpressionDialect_ + i));
		}
	}
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
			if (soap_out_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, a->TopicExpression_ + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->FixedTopicSet, ""))
		return soap->error;
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, (char*const*)(a->TopicExpressionDialect_ + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, struct _wsnt__NotificationProducerRP *a, const char *type)
{
	struct soap_blist *soap_blist_TopicExpression_ = NULL;
	size_t soap_flag_FixedTopicSet = 1;
	struct soap_blist *soap_blist_TopicExpressionDialect_ = NULL;
	size_t soap_flag_wstop__TopicSet = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationProducerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationProducerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpression", 1, NULL))
			{	if (a->TopicExpression_ == NULL)
				{	if (soap_blist_TopicExpression_ == NULL)
						soap_blist_TopicExpression_ = soap_alloc_block(soap);
					a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_push_block_max(soap, soap_blist_TopicExpression_, sizeof(struct wsnt__TopicExpressionType));
					if (a->TopicExpression_ == NULL)
						return NULL;
					soap_default_wsnt__TopicExpressionType(soap, a->TopicExpression_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", a->TopicExpression_, "wsnt:TopicExpressionType"))
				{	a->__sizeTopicExpression++;
					a->TopicExpression_ = NULL;
					continue;
				}
			}
			if (soap_flag_FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", &a->FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->FixedTopicSet = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
						return NULL;
					*a->FixedTopicSet = (enum xsd__boolean)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->TopicExpressionDialect_ == NULL)
				{	if (soap_blist_TopicExpressionDialect_ == NULL)
						soap_blist_TopicExpressionDialect_ = soap_alloc_block(soap);
					a->TopicExpressionDialect_ = (char **)soap_push_block_max(soap, soap_blist_TopicExpressionDialect_, sizeof(char *));
					if (a->TopicExpressionDialect_ == NULL)
						return NULL;
					*a->TopicExpressionDialect_ = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", (char**)a->TopicExpressionDialect_, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->TopicExpressionDialect_ = NULL;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicExpression_)
			soap_pop_block(soap, soap_blist_TopicExpression_);
		if (a->__sizeTopicExpression)
		{	a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_save_block(soap, soap_blist_TopicExpression_, NULL, 1);
		}
		else
		{	a->TopicExpression_ = NULL;
			if (soap_blist_TopicExpression_)
				soap_end_block(soap, soap_blist_TopicExpression_);
		}
		if (a->TopicExpressionDialect_)
			soap_pop_block(soap, soap_blist_TopicExpressionDialect_);
		if (a->__sizeTopicExpressionDialect)
		{	a->TopicExpressionDialect_ = (char **)soap_save_block(soap, soap_blist_TopicExpressionDialect_, NULL, 1);
		}
		else
		{	a->TopicExpressionDialect_ = NULL;
			if (soap_blist_TopicExpressionDialect_)
				soap_end_block(soap, soap_blist_TopicExpressionDialect_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_new__wsnt__NotificationProducerRP(struct soap *soap, int n)
{
	struct _wsnt__NotificationProducerRP *p;
	struct _wsnt__NotificationProducerRP *a = (struct _wsnt__NotificationProducerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationProducerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationProducerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_new__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n)
{
	struct _wsnt__NotificationMessageHolderType_Message *p;
	struct _wsnt__NotificationMessageHolderType_Message *a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationMessageHolderType_Message));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationMessageHolderType_Message(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag ? tag : "wsnt:NotificationMessageHolderType-Message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscriptionPolicyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscriptionPolicyType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_new_wsnt__SubscriptionPolicyType(struct soap *soap, int n)
{
	struct wsnt__SubscriptionPolicyType *p;
	struct wsnt__SubscriptionPolicyType *a = (struct wsnt__SubscriptionPolicyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscriptionPolicyType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscriptionPolicyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__anyAttribute = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionType *p;
	struct wsnt__TopicExpressionType *a = (struct wsnt__TopicExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_new_wsnt__QueryExpressionType(struct soap *soap, int n)
{
	struct wsnt__QueryExpressionType *p;
	struct wsnt__QueryExpressionType *a = (struct wsnt__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_FaultCause *p;
	struct _wsrfbf__BaseFaultType_FaultCause *a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfbf__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfbf__BaseFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_Description *p;
	struct _wsrfbf__BaseFaultType_Description *a = (struct _wsrfbf__BaseFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_ErrorCode *p;
	struct _wsrfbf__BaseFaultType_ErrorCode *a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			soap_serialize__wsrfbf__BaseFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const struct wsrfbf__BaseFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, struct wsrfbf__BaseFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfbf__BaseFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfbf__BaseFaultType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_alloc_block(soap);
					a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_push_block_max(soap, soap_blist_Description, sizeof(struct _wsrfbf__BaseFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsrfbf__BaseFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
		{	a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		}
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_new_wsrfbf__BaseFaultType(struct soap *soap, int n)
{
	struct wsrfbf__BaseFaultType *p;
	struct wsrfbf__BaseFaultType *a = (struct wsrfbf__BaseFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfbf__BaseFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfbf__BaseFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEventBroker = 0;
	a->EventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventBrokersResponse(struct soap *soap, const struct _tev__GetEventBrokersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EventBroker)
	{	int i;
		for (i = 0; i < (int)a->__sizeEventBroker; i++)
		{
			soap_embedded(soap, a->EventBroker + i, SOAP_TYPE_tev__EventBrokerConfig);
			soap_serialize_tev__EventBrokerConfig(soap, a->EventBroker + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventBrokersResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetEventBrokersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventBrokersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeEventBroker");
	if (a->EventBroker)
	{	int i;
		for (i = 0; i < (int)a->__sizeEventBroker; i++)
			if (soap_out_tev__EventBrokerConfig(soap, "tev:EventBroker", -1, a->EventBroker + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_in__tev__GetEventBrokersResponse(struct soap *soap, const char *tag, struct _tev__GetEventBrokersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_EventBroker = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventBrokersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventBrokersResponse, sizeof(struct _tev__GetEventBrokersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventBrokersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:EventBroker", 1, NULL))
			{	if (a->EventBroker == NULL)
				{	if (soap_blist_EventBroker == NULL)
						soap_blist_EventBroker = soap_alloc_block(soap);
					a->EventBroker = (struct tev__EventBrokerConfig *)soap_push_block_max(soap, soap_blist_EventBroker, sizeof(struct tev__EventBrokerConfig));
					if (a->EventBroker == NULL)
						return NULL;
					soap_default_tev__EventBrokerConfig(soap, a->EventBroker);
				}
				soap_revert(soap);
				if (soap_in_tev__EventBrokerConfig(soap, "tev:EventBroker", a->EventBroker, "tev:EventBrokerConfig"))
				{	a->__sizeEventBroker++;
					a->EventBroker = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeEventBroker");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EventBroker)
			soap_pop_block(soap, soap_blist_EventBroker);
		if (a->__sizeEventBroker)
		{	a->EventBroker = (struct tev__EventBrokerConfig *)soap_save_block(soap, soap_blist_EventBroker, NULL, 1);
		}
		else
		{	a->EventBroker = NULL;
			if (soap_blist_EventBroker)
				soap_end_block(soap, soap_blist_EventBroker);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventBrokersResponse, SOAP_TYPE__tev__GetEventBrokersResponse, sizeof(struct _tev__GetEventBrokersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_new__tev__GetEventBrokersResponse(struct soap *soap, int n)
{
	struct _tev__GetEventBrokersResponse *p;
	struct _tev__GetEventBrokersResponse *a = (struct _tev__GetEventBrokersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventBrokersResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventBrokersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventBrokersResponse(struct soap *soap, const struct _tev__GetEventBrokersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventBrokersResponse(soap, tag ? tag : "tev:GetEventBrokersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_get__tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventBrokersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventBrokers(struct soap *soap, const struct _tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventBrokers(struct soap *soap, const char *tag, int id, const struct _tev__GetEventBrokers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventBrokers), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_in__tev__GetEventBrokers(struct soap *soap, const char *tag, struct _tev__GetEventBrokers *a, const char *type)
{
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventBrokers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventBrokers, sizeof(struct _tev__GetEventBrokers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventBrokers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventBrokers, SOAP_TYPE__tev__GetEventBrokers, sizeof(struct _tev__GetEventBrokers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_new__tev__GetEventBrokers(struct soap *soap, int n)
{
	struct _tev__GetEventBrokers *p;
	struct _tev__GetEventBrokers *a = (struct _tev__GetEventBrokers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventBrokers));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventBrokers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventBrokers(struct soap *soap, const struct _tev__GetEventBrokers *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventBrokers(soap, tag ? tag : "tev:GetEventBrokers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_get__tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventBrokers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__DeleteEventBrokerResponse(struct soap *soap, const struct _tev__DeleteEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, int id, const struct _tev__DeleteEventBrokerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__DeleteEventBrokerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_in__tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__DeleteEventBrokerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__DeleteEventBrokerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__DeleteEventBrokerResponse, sizeof(struct _tev__DeleteEventBrokerResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__DeleteEventBrokerResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBrokerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__DeleteEventBrokerResponse, SOAP_TYPE__tev__DeleteEventBrokerResponse, sizeof(struct _tev__DeleteEventBrokerResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_new__tev__DeleteEventBrokerResponse(struct soap *soap, int n)
{
	struct _tev__DeleteEventBrokerResponse *p;
	struct _tev__DeleteEventBrokerResponse *a = (struct _tev__DeleteEventBrokerResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__DeleteEventBrokerResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__DeleteEventBrokerResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__DeleteEventBrokerResponse(struct soap *soap, const struct _tev__DeleteEventBrokerResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__DeleteEventBrokerResponse(soap, tag ? tag : "tev:DeleteEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_get__tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__DeleteEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__DeleteEventBroker(struct soap *soap, const struct _tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__DeleteEventBroker(struct soap *soap, const char *tag, int id, const struct _tev__DeleteEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__DeleteEventBroker), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tev:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_in__tev__DeleteEventBroker(struct soap *soap, const char *tag, struct _tev__DeleteEventBroker *a, const char *type)
{
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__DeleteEventBroker*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__DeleteEventBroker, sizeof(struct _tev__DeleteEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__DeleteEventBroker(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBroker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__DeleteEventBroker, SOAP_TYPE__tev__DeleteEventBroker, sizeof(struct _tev__DeleteEventBroker), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_new__tev__DeleteEventBroker(struct soap *soap, int n)
{
	struct _tev__DeleteEventBroker *p;
	struct _tev__DeleteEventBroker *a = (struct _tev__DeleteEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__DeleteEventBroker));
	for (p = a; p && n--; p++)
		soap_default__tev__DeleteEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__DeleteEventBroker(struct soap *soap, const struct _tev__DeleteEventBroker *a, const char *tag, const char *type)
{
	if (soap_out__tev__DeleteEventBroker(soap, tag ? tag : "tev:DeleteEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_get__tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__DeleteEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__AddEventBrokerResponse(struct soap *soap, const struct _tev__AddEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__AddEventBrokerResponse(struct soap *soap, const char *tag, int id, const struct _tev__AddEventBrokerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__AddEventBrokerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_in__tev__AddEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__AddEventBrokerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__AddEventBrokerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__AddEventBrokerResponse, sizeof(struct _tev__AddEventBrokerResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__AddEventBrokerResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__AddEventBrokerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__AddEventBrokerResponse, SOAP_TYPE__tev__AddEventBrokerResponse, sizeof(struct _tev__AddEventBrokerResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_new__tev__AddEventBrokerResponse(struct soap *soap, int n)
{
	struct _tev__AddEventBrokerResponse *p;
	struct _tev__AddEventBrokerResponse *a = (struct _tev__AddEventBrokerResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__AddEventBrokerResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__AddEventBrokerResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__AddEventBrokerResponse(struct soap *soap, const struct _tev__AddEventBrokerResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__AddEventBrokerResponse(soap, tag ? tag : "tev:AddEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_get__tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__AddEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__AddEventBroker(struct soap *soap, const struct _tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__EventBrokerConfig(soap, &a->EventBroker);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__AddEventBroker(struct soap *soap, const char *tag, int id, const struct _tev__AddEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__AddEventBroker), type))
		return soap->error;
	if (!a->EventBroker)
	{	if (soap_element_empty(soap, "tev:EventBroker", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotev__EventBrokerConfig(soap, "tev:EventBroker", -1, &a->EventBroker, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_in__tev__AddEventBroker(struct soap *soap, const char *tag, struct _tev__AddEventBroker *a, const char *type)
{
	size_t soap_flag_EventBroker = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__AddEventBroker*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__AddEventBroker, sizeof(struct _tev__AddEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__AddEventBroker(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventBroker && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__EventBrokerConfig(soap, "tev:EventBroker", &a->EventBroker, "tev:EventBrokerConfig"))
				{	soap_flag_EventBroker--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->EventBroker))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__AddEventBroker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__AddEventBroker, SOAP_TYPE__tev__AddEventBroker, sizeof(struct _tev__AddEventBroker), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_new__tev__AddEventBroker(struct soap *soap, int n)
{
	struct _tev__AddEventBroker *p;
	struct _tev__AddEventBroker *a = (struct _tev__AddEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__AddEventBroker));
	for (p = a; p && n--; p++)
		soap_default__tev__AddEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__AddEventBroker(struct soap *soap, const struct _tev__AddEventBroker *a, const char *tag, const char *type)
{
	if (soap_out__tev__AddEventBroker(soap, tag ? tag : "tev:AddEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_get__tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__AddEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const struct wstop__TopicSetType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicSetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicSetType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_new_wstop__TopicSetType(struct soap *soap, int n)
{
	struct wstop__TopicSetType *p;
	struct wstop__TopicSetType *a = (struct wstop__TopicSetType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicSetType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicSetType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicNamespaceLocation = 0;
	a->TopicNamespaceLocation = NULL;
	a->wsnt__FixedTopicSet = (enum xsd__boolean)1;
	a->wstop__TopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->wsnt__TopicExpressionDialect = NULL;
	a->__sizeMessageContentFilterDialect = 0;
	a->MessageContentFilterDialect = NULL;
	a->__sizeProducerPropertiesFilterDialect = 0;
	a->ProducerPropertiesFilterDialect = NULL;
	a->__sizeMessageContentSchemaLocation = 0;
	a->MessageContentSchemaLocation = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicNamespaceLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->TopicNamespaceLocation + i));
		}
	}
	soap_embedded(soap, &a->wsnt__FixedTopicSet, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->wsnt__TopicExpressionDialect + i));
		}
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->MessageContentFilterDialect + i));
		}
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeProducerPropertiesFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ProducerPropertiesFilterDialect + i));
		}
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->MessageContentSchemaLocation + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventPropertiesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeTopicNamespaceLocation");
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicNamespaceLocation; i++)
			if (soap_out_string(soap, "tev:TopicNamespaceLocation", -1, (char*const*)(a->TopicNamespaceLocation + i), ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->wsnt__FixedTopicSet, ""))
		return soap->error;
	if (!a->wstop__TopicSet)
	{	if (soap_element_empty(soap, "wstop:TopicSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, (char*const*)(a->wsnt__TopicExpressionDialect + i), ""))
				return soap->error;
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentFilterDialect; i++)
			if (soap_out_string(soap, "tev:MessageContentFilterDialect", -1, (char*const*)(a->MessageContentFilterDialect + i), ""))
				return soap->error;
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeProducerPropertiesFilterDialect; i++)
			if (soap_out_string(soap, "tev:ProducerPropertiesFilterDialect", -1, (char*const*)(a->ProducerPropertiesFilterDialect + i), ""))
				return soap->error;
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentSchemaLocation; i++)
			if (soap_out_string(soap, "tev:MessageContentSchemaLocation", -1, (char*const*)(a->MessageContentSchemaLocation + i), ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_in__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_TopicNamespaceLocation = NULL;
	size_t soap_flag_wsnt__FixedTopicSet = 1;
	size_t soap_flag_wstop__TopicSet = 1;
	struct soap_blist *soap_blist_wsnt__TopicExpressionDialect = NULL;
	struct soap_blist *soap_blist_MessageContentFilterDialect = NULL;
	struct soap_blist *soap_blist_ProducerPropertiesFilterDialect = NULL;
	struct soap_blist *soap_blist_MessageContentSchemaLocation = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventPropertiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventPropertiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:TopicNamespaceLocation", 1, NULL))
			{	if (a->TopicNamespaceLocation == NULL)
				{	if (soap_blist_TopicNamespaceLocation == NULL)
						soap_blist_TopicNamespaceLocation = soap_alloc_block(soap);
					a->TopicNamespaceLocation = (char **)soap_push_block_max(soap, soap_blist_TopicNamespaceLocation, sizeof(char *));
					if (a->TopicNamespaceLocation == NULL)
						return NULL;
					*a->TopicNamespaceLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:TopicNamespaceLocation", (char**)a->TopicNamespaceLocation, "xsd:anyURI"))
				{	a->__sizeTopicNamespaceLocation++;
					a->TopicNamespaceLocation = NULL;
					continue;
				}
			}
			if (soap_flag_wsnt__FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "wsnt:FixedTopicSet", &a->wsnt__FixedTopicSet, "xsd:boolean"))
				{	soap_flag_wsnt__FixedTopicSet--;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->wsnt__TopicExpressionDialect == NULL)
				{	if (soap_blist_wsnt__TopicExpressionDialect == NULL)
						soap_blist_wsnt__TopicExpressionDialect = soap_alloc_block(soap);
					a->wsnt__TopicExpressionDialect = (char **)soap_push_block_max(soap, soap_blist_wsnt__TopicExpressionDialect, sizeof(char *));
					if (a->wsnt__TopicExpressionDialect == NULL)
						return NULL;
					*a->wsnt__TopicExpressionDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", (char**)a->wsnt__TopicExpressionDialect, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->wsnt__TopicExpressionDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentFilterDialect", 1, NULL))
			{	if (a->MessageContentFilterDialect == NULL)
				{	if (soap_blist_MessageContentFilterDialect == NULL)
						soap_blist_MessageContentFilterDialect = soap_alloc_block(soap);
					a->MessageContentFilterDialect = (char **)soap_push_block_max(soap, soap_blist_MessageContentFilterDialect, sizeof(char *));
					if (a->MessageContentFilterDialect == NULL)
						return NULL;
					*a->MessageContentFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentFilterDialect", (char**)a->MessageContentFilterDialect, "xsd:anyURI"))
				{	a->__sizeMessageContentFilterDialect++;
					a->MessageContentFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:ProducerPropertiesFilterDialect", 1, NULL))
			{	if (a->ProducerPropertiesFilterDialect == NULL)
				{	if (soap_blist_ProducerPropertiesFilterDialect == NULL)
						soap_blist_ProducerPropertiesFilterDialect = soap_alloc_block(soap);
					a->ProducerPropertiesFilterDialect = (char **)soap_push_block_max(soap, soap_blist_ProducerPropertiesFilterDialect, sizeof(char *));
					if (a->ProducerPropertiesFilterDialect == NULL)
						return NULL;
					*a->ProducerPropertiesFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", (char**)a->ProducerPropertiesFilterDialect, "xsd:anyURI"))
				{	a->__sizeProducerPropertiesFilterDialect++;
					a->ProducerPropertiesFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentSchemaLocation", 1, NULL))
			{	if (a->MessageContentSchemaLocation == NULL)
				{	if (soap_blist_MessageContentSchemaLocation == NULL)
						soap_blist_MessageContentSchemaLocation = soap_alloc_block(soap);
					a->MessageContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_MessageContentSchemaLocation, sizeof(char *));
					if (a->MessageContentSchemaLocation == NULL)
						return NULL;
					*a->MessageContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentSchemaLocation", (char**)a->MessageContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeMessageContentSchemaLocation++;
					a->MessageContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeTopicNamespaceLocation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicNamespaceLocation)
			soap_pop_block(soap, soap_blist_TopicNamespaceLocation);
		if (a->__sizeTopicNamespaceLocation)
		{	a->TopicNamespaceLocation = (char **)soap_save_block(soap, soap_blist_TopicNamespaceLocation, NULL, 1);
		}
		else
		{	a->TopicNamespaceLocation = NULL;
			if (soap_blist_TopicNamespaceLocation)
				soap_end_block(soap, soap_blist_TopicNamespaceLocation);
		}
		if (a->wsnt__TopicExpressionDialect)
			soap_pop_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		if (a->__sizeTopicExpressionDialect)
		{	a->wsnt__TopicExpressionDialect = (char **)soap_save_block(soap, soap_blist_wsnt__TopicExpressionDialect, NULL, 1);
		}
		else
		{	a->wsnt__TopicExpressionDialect = NULL;
			if (soap_blist_wsnt__TopicExpressionDialect)
				soap_end_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		}
		if (a->MessageContentFilterDialect)
			soap_pop_block(soap, soap_blist_MessageContentFilterDialect);
		if (a->__sizeMessageContentFilterDialect)
		{	a->MessageContentFilterDialect = (char **)soap_save_block(soap, soap_blist_MessageContentFilterDialect, NULL, 1);
		}
		else
		{	a->MessageContentFilterDialect = NULL;
			if (soap_blist_MessageContentFilterDialect)
				soap_end_block(soap, soap_blist_MessageContentFilterDialect);
		}
		if (a->ProducerPropertiesFilterDialect)
			soap_pop_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		if (a->__sizeProducerPropertiesFilterDialect)
		{	a->ProducerPropertiesFilterDialect = (char **)soap_save_block(soap, soap_blist_ProducerPropertiesFilterDialect, NULL, 1);
		}
		else
		{	a->ProducerPropertiesFilterDialect = NULL;
			if (soap_blist_ProducerPropertiesFilterDialect)
				soap_end_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		}
		if (a->MessageContentSchemaLocation)
			soap_pop_block(soap, soap_blist_MessageContentSchemaLocation);
		if (a->__sizeMessageContentSchemaLocation)
		{	a->MessageContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_MessageContentSchemaLocation, NULL, 1);
		}
		else
		{	a->MessageContentSchemaLocation = NULL;
			if (soap_blist_MessageContentSchemaLocation)
				soap_end_block(soap, soap_blist_MessageContentSchemaLocation);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTopicNamespaceLocation < 1 || soap_flag_wsnt__FixedTopicSet > 0 || !a->wstop__TopicSet || a->__sizeTopicExpressionDialect < 1 || a->__sizeMessageContentFilterDialect < 1 || a->__sizeMessageContentSchemaLocation < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_new__tev__GetEventPropertiesResponse(struct soap *soap, int n)
{
	struct _tev__GetEventPropertiesResponse *p;
	struct _tev__GetEventPropertiesResponse *a = (struct _tev__GetEventPropertiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventPropertiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventPropertiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventPropertiesResponse(soap, tag ? tag : "tev:GetEventPropertiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_get__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventProperties(struct soap *soap, const char *tag, int id, const struct _tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventProperties), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_in__tev__GetEventProperties(struct soap *soap, const char *tag, struct _tev__GetEventProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventProperties(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_new__tev__GetEventProperties(struct soap *soap, int n)
{
	struct _tev__GetEventProperties *p;
	struct _tev__GetEventProperties *a = (struct _tev__GetEventProperties*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventProperties));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventProperties(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_get__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SetSynchronizationPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPointResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_new__tev__SetSynchronizationPointResponse(struct soap *soap, int n)
{
	struct _tev__SetSynchronizationPointResponse *p;
	struct _tev__SetSynchronizationPointResponse *a = (struct _tev__SetSynchronizationPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SetSynchronizationPointResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__SetSynchronizationPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__SetSynchronizationPointResponse(soap, tag ? tag : "tev:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPoint), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SetSynchronizationPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPoint(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_new__tev__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct _tev__SetSynchronizationPoint *p;
	struct _tev__SetSynchronizationPoint *a = (struct _tev__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default__tev__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out__tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SeekResponse(struct soap *soap, const struct _tev__SeekResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SeekResponse(struct soap *soap, const char *tag, int id, const struct _tev__SeekResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SeekResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_in__tev__SeekResponse(struct soap *soap, const char *tag, struct _tev__SeekResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SeekResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SeekResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SeekResponse, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_new__tev__SeekResponse(struct soap *soap, int n)
{
	struct _tev__SeekResponse *p;
	struct _tev__SeekResponse *a = (struct _tev__SeekResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SeekResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__SeekResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SeekResponse(struct soap *soap, const struct _tev__SeekResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__SeekResponse(soap, tag ? tag : "tev:SeekResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_get__tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__Seek(struct soap *soap, struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->UtcTime);
	a->Reverse = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__Seek(struct soap *soap, const struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerToxsd__boolean(soap, &a->Reverse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__Seek(struct soap *soap, const char *tag, int id, const struct _tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__Seek), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tev:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_in__tev__Seek(struct soap *soap, const char *tag, struct _tev__Seek *a, const char *type)
{
	size_t soap_flag_UtcTime = 1;
	size_t soap_flag_Reverse = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__Seek*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__Seek(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tev:Reverse", &a->Reverse, "xsd:boolean"))
				{	soap_flag_Reverse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_new__tev__Seek(struct soap *soap, int n)
{
	struct _tev__Seek *p;
	struct _tev__Seek *a = (struct _tev__Seek*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__Seek));
	for (p = a; p && n--; p++)
		soap_default__tev__Seek(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__Seek(struct soap *soap, const struct _tev__Seek *a, const char *tag, const char *type)
{
	if (soap_out__tev__Seek(soap, tag ? tag : "tev:Seek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_get__tev__Seek(struct soap *soap, struct _tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->MaxTimeout);
	soap_default_int(soap, &a->MaxMessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->MaxTimeout);
	soap_embedded(soap, &a->MaxMessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (!a->MaxTimeout)
	{	if (soap_element_empty(soap, "tev:MaxTimeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, (char*const*)&a->MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->MaxMessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	size_t soap_flag_MaxTimeout = 1;
	size_t soap_flag_MaxMessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessagesFaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesFaultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tev:MaxTimeout", (char**)&a->MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout--;
					continue;
				}
			}
			if (soap_flag_MaxMessageLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MaxMessageLimit", &a->MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MaxTimeout || soap_flag_MaxMessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_new__tev__PullMessagesFaultResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesFaultResponse *p;
	struct _tev__PullMessagesFaultResponse *a = (struct _tev__PullMessagesFaultResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesFaultResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesFaultResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotificationMessageHolderType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotificationMessageHolderType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_new_wsnt__NotificationMessageHolderType(struct soap *soap, int n)
{
	struct wsnt__NotificationMessageHolderType *p;
	struct wsnt__NotificationMessageHolderType *a = (struct wsnt__NotificationMessageHolderType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotificationMessageHolderType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotificationMessageHolderType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->CurrentTime);
	soap_default_dateTime(soap, &a->TerminationTime);
	a->__sizeNotificationMessage = 0;
	a->wsnt__NotificationMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->wsnt__NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_dateTime(soap, "tev:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->wsnt__NotificationMessage + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse *a, const char *type)
{
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist_wsnt__NotificationMessage = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->wsnt__NotificationMessage == NULL)
				{	if (soap_blist_wsnt__NotificationMessage == NULL)
						soap_blist_wsnt__NotificationMessage = soap_alloc_block(soap);
					a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_wsnt__NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->wsnt__NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->wsnt__NotificationMessage = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsnt__NotificationMessage)
			soap_pop_block(soap, soap_blist_wsnt__NotificationMessage);
		if (a->__sizeNotificationMessage)
		{	a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_wsnt__NotificationMessage, NULL, 1);
		}
		else
		{	a->wsnt__NotificationMessage = NULL;
			if (soap_blist_wsnt__NotificationMessage)
				soap_end_block(soap, soap_blist_wsnt__NotificationMessage);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime > 0 || soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_new__tev__PullMessagesResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesResponse *p;
	struct _tev__PullMessagesResponse *a = (struct _tev__PullMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Timeout);
	soap_default_int(soap, &a->MessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->Timeout);
	soap_embedded(soap, &a->MessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const struct _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (!a->Timeout)
	{	if (soap_element_empty(soap, "tev:Timeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tev:Timeout", -1, (char*const*)&a->Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->MessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages *a, const char *type)
{
	size_t soap_flag_Timeout = 1;
	size_t soap_flag_MessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessages(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tev:Timeout", (char**)&a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			}
			if (soap_flag_MessageLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MessageLimit", &a->MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Timeout || soap_flag_MessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_new__tev__PullMessages(struct soap *soap, int n)
{
	struct _tev__PullMessages *p;
	struct _tev__PullMessages *a = (struct _tev__PullMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessages));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_default_dateTime(soap, &a->wsnt__CurrentTime);
	soap_default_dateTime(soap, &a->wsnt__TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_embedded(soap, &a->wsnt__CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->wsnt__TerminationTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:CurrentTime", -1, &a->wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->wsnt__TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_wsnt__CurrentTime = 1;
	size_t soap_flag_wsnt__TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_wsnt__CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:CurrentTime", &a->wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime--;
					continue;
				}
			}
			if (soap_flag_wsnt__TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0 || soap_flag_wsnt__CurrentTime > 0 || soap_flag_wsnt__TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscriptionResponse(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscriptionResponse *p;
	struct _tev__CreatePullPointSubscriptionResponse *a = (struct _tev__CreatePullPointSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p;
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription *p;
	struct _tev__CreatePullPointSubscription *a = (struct _tev__CreatePullPointSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tev:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tev__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilitiesResponse *p;
	struct _tev__GetServiceCapabilitiesResponse *a = (struct _tev__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_new__tev__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilities *p;
	struct _tev__GetServiceCapabilities *a = (struct _tev__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const struct wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__FilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__FilterType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_new_wsnt__FilterType(struct soap *soap, int n)
{
	struct wsnt__FilterType *p;
	struct wsnt__FilterType *a = (struct wsnt__FilterType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__FilterType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__FilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
	soap_default_string(soap, &a->TopicPrefix);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__token(soap, &a->CertificateID);
	a->PublishFilter = NULL;
	a->QoS = NULL;
	soap_default_string(soap, &a->Status);
	soap_default_string(soap, &a->CertPathValidationPolicyID);
	a->MetadataFilter = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__EventBrokerConfig(struct soap *soap, const struct tev__EventBrokerConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
	soap_serialize_string(soap, (char*const*)&a->TopicPrefix);
	soap_serialize_string(soap, (char*const*)&a->UserName);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->PublishFilter);
	soap_serialize_PointerToint(soap, &a->QoS);
	soap_serialize_string(soap, (char*const*)&a->Status);
	soap_serialize_string(soap, (char*const*)&a->CertPathValidationPolicyID);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->MetadataFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__EventBrokerConfig(struct soap *soap, const char *tag, int id, const struct tev__EventBrokerConfig *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__EventBrokerConfig), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tev:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (!a->TopicPrefix)
	{	if (soap_element_empty(soap, "tev:TopicPrefix", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tev:TopicPrefix", -1, (char*const*)&a->TopicPrefix, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:UserName", -1, (char*const*)&a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tev:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:PublishFilter", -1, &a->PublishFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tev:QoS", -1, &a->QoS, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:Status", -1, (char*const*)&a->Status, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:CertPathValidationPolicyID", -1, (char*const*)&a->CertPathValidationPolicyID, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:MetadataFilter", -1, &a->MetadataFilter, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_in_tev__EventBrokerConfig(struct soap *soap, const char *tag, struct tev__EventBrokerConfig *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_TopicPrefix = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_PublishFilter = 1;
	size_t soap_flag_QoS = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_CertPathValidationPolicyID = 1;
	size_t soap_flag_MetadataFilter = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tev__EventBrokerConfig*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__EventBrokerConfig, sizeof(struct tev__EventBrokerConfig), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__EventBrokerConfig(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_TopicPrefix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:TopicPrefix", (char**)&a->TopicPrefix, "xsd:string"))
				{	soap_flag_TopicPrefix--;
					continue;
				}
			}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:UserName", (char**)&a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tev:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_PublishFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:PublishFilter", &a->PublishFilter, "wsnt:FilterType"))
				{	soap_flag_PublishFilter--;
					continue;
				}
			}
			if (soap_flag_QoS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tev:QoS", &a->QoS, "xsd:int"))
				{	soap_flag_QoS--;
					continue;
				}
			}
			if (soap_flag_Status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:Status", (char**)&a->Status, "xsd:string"))
				{	soap_flag_Status--;
					continue;
				}
			}
			if (soap_flag_CertPathValidationPolicyID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:CertPathValidationPolicyID", (char**)&a->CertPathValidationPolicyID, "xsd:string"))
				{	soap_flag_CertPathValidationPolicyID--;
					continue;
				}
			}
			if (soap_flag_MetadataFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:MetadataFilter", &a->MetadataFilter, "wsnt:FilterType"))
				{	soap_flag_MetadataFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || !a->TopicPrefix))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tev__EventBrokerConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__EventBrokerConfig, SOAP_TYPE_tev__EventBrokerConfig, sizeof(struct tev__EventBrokerConfig), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_new_tev__EventBrokerConfig(struct soap *soap, int n)
{
	struct tev__EventBrokerConfig *p;
	struct tev__EventBrokerConfig *a = (struct tev__EventBrokerConfig*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__EventBrokerConfig));
	for (p = a; p && n--; p++)
		soap_default_tev__EventBrokerConfig(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__EventBrokerConfig(struct soap *soap, const struct tev__EventBrokerConfig *a, const char *tag, const char *type)
{
	if (soap_out_tev__EventBrokerConfig(soap, tag ? tag : "tev:EventBrokerConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_get_tev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__EventBrokerConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__Capabilities(struct soap *soap, struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->WSSubscriptionPolicySupport = NULL;
	a->WSPullPointSupport = NULL;
	a->WSPausableSubscriptionManagerInterfaceSupport = NULL;
	a->MaxNotificationProducers = NULL;
	a->MaxPullPoints = NULL;
	a->PersistentNotificationStorage = NULL;
	soap_default_string(soap, &a->EventBrokerProtocols);
	a->MaxEventBrokers = NULL;
	a->MetadataOverMQTT = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const struct tev__Capabilities *a, const char *type)
{
	if (a->WSSubscriptionPolicySupport)
	{	soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_xsd__boolean2s(soap, *a->WSSubscriptionPolicySupport), 1);
	}
	if (a->WSPullPointSupport)
	{	soap_set_attr(soap, "WSPullPointSupport", soap_xsd__boolean2s(soap, *a->WSPullPointSupport), 1);
	}
	if (a->WSPausableSubscriptionManagerInterfaceSupport)
	{	soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_xsd__boolean2s(soap, *a->WSPausableSubscriptionManagerInterfaceSupport), 1);
	}
	if (a->MaxNotificationProducers)
	{	soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *a->MaxNotificationProducers), 1);
	}
	if (a->MaxPullPoints)
	{	soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *a->MaxPullPoints), 1);
	}
	if (a->PersistentNotificationStorage)
	{	soap_set_attr(soap, "PersistentNotificationStorage", soap_xsd__boolean2s(soap, *a->PersistentNotificationStorage), 1);
	}
	if (a->EventBrokerProtocols)
		soap_set_attr(soap, "EventBrokerProtocols", soap_string2s(soap, a->EventBrokerProtocols), 1);
	if (a->MaxEventBrokers)
	{	soap_set_attr(soap, "MaxEventBrokers", soap_int2s(soap, *a->MaxEventBrokers), 1);
	}
	if (a->MetadataOverMQTT)
	{	soap_set_attr(soap, "MetadataOverMQTT", soap_xsd__boolean2s(soap, *a->MetadataOverMQTT), 1);
	}
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tev__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 5, 0);
		if (t)
		{
			if (!(a->WSSubscriptionPolicySupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSSubscriptionPolicySupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPullPointSupport", 5, 0);
		if (t)
		{
			if (!(a->WSPullPointSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPullPointSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 5, 0);
		if (t)
		{
			if (!(a->WSPausableSubscriptionManagerInterfaceSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPausableSubscriptionManagerInterfaceSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxNotificationProducers", 5, 0);
		if (t)
		{
			if (!(a->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPullPoints", 5, 0);
		if (t)
		{
			if (!(a->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PersistentNotificationStorage", 5, 0);
		if (t)
		{
			if (!(a->PersistentNotificationStorage = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->PersistentNotificationStorage))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "EventBrokerProtocols", 1, 0), &a->EventBrokerProtocols))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaxEventBrokers", 5, 0);
		if (t)
		{
			if (!(a->MaxEventBrokers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxEventBrokers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MetadataOverMQTT", 5, 0);
		if (t)
		{
			if (!(a->MetadataOverMQTT = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataOverMQTT))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_new_tev__Capabilities(struct soap *soap, int n)
{
	struct tev__Capabilities *p;
	struct tev__Capabilities *a = (struct tev__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tev__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, struct tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsnt__InvalidFilterFault = NULL;
	a->wsnt__InvalidMessageContentExpressionFault = NULL;
	a->wsnt__InvalidProducerPropertiesExpressionFault = NULL;
	a->wsnt__InvalidTopicExpressionFault = NULL;
	a->wsnt__MultipleTopicsSpecifiedFault = NULL;
	a->wsnt__NoCurrentMessageOnTopicFault = NULL;
	a->wsnt__NotifyMessageNotSupportedFault = NULL;
	a->wsnt__PauseFailedFault = NULL;
	a->tev__PullMessagesFaultResponse = NULL;
	a->wsrfr__ResourceUnknownFault = NULL;
	a->wsnt__ResumeFailedFault = NULL;
	a->wsnt__SubscribeCreationFailedFault = NULL;
	a->wsnt__TopicExpressionDialectUnknownFault = NULL;
	a->wsnt__TopicNotSupportedFault = NULL;
	a->wsnt__UnableToCreatePullPointFault = NULL;
	a->wsnt__UnableToDestroyPullPointFault = NULL;
	a->wsnt__UnableToDestroySubscriptionFault = NULL;
	a->wsnt__UnableToGetMessagesFault = NULL;
	a->wsnt__UnacceptableInitialTerminationTimeFault = NULL;
	a->wsnt__UnacceptableTerminationTimeFault = NULL;
	a->wsnt__UnrecognizedPolicyRequestFault = NULL;
	a->wsnt__UnsupportedPolicyRequestFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, &a->wsnt__InvalidFilterFault);
	soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, &a->wsnt__InvalidMessageContentExpressionFault);
	soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, &a->wsnt__InvalidProducerPropertiesExpressionFault);
	soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, &a->wsnt__InvalidTopicExpressionFault);
	soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, &a->wsnt__MultipleTopicsSpecifiedFault);
	soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, &a->wsnt__NoCurrentMessageOnTopicFault);
	soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, &a->wsnt__NotifyMessageNotSupportedFault);
	soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, &a->wsnt__PauseFailedFault);
	soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, &a->tev__PullMessagesFaultResponse);
	soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, &a->wsrfr__ResourceUnknownFault);
	soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, &a->wsnt__ResumeFailedFault);
	soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, &a->wsnt__SubscribeCreationFailedFault);
	soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, &a->wsnt__TopicExpressionDialectUnknownFault);
	soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, &a->wsnt__TopicNotSupportedFault);
	soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, &a->wsnt__UnableToCreatePullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, &a->wsnt__UnableToDestroyPullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, &a->wsnt__UnableToDestroySubscriptionFault);
	soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, &a->wsnt__UnableToGetMessagesFault);
	soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, &a->wsnt__UnacceptableInitialTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, &a->wsnt__UnacceptableTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, &a->wsnt__UnrecognizedPolicyRequestFault);
	soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, &a->wsnt__UnsupportedPolicyRequestFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", -1, &a->wsnt__InvalidFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", -1, &a->wsnt__InvalidMessageContentExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", -1, &a->wsnt__InvalidProducerPropertiesExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", -1, &a->wsnt__InvalidTopicExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", -1, &a->wsnt__MultipleTopicsSpecifiedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", -1, &a->wsnt__NoCurrentMessageOnTopicFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", -1, &a->wsnt__NotifyMessageNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", -1, &a->wsnt__PauseFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", -1, &a->tev__PullMessagesFaultResponse, ""))
		return soap->error;
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", -1, &a->wsrfr__ResourceUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", -1, &a->wsnt__ResumeFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", -1, &a->wsnt__SubscribeCreationFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", -1, &a->wsnt__TopicExpressionDialectUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", -1, &a->wsnt__TopicNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", -1, &a->wsnt__UnableToCreatePullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", -1, &a->wsnt__UnableToDestroyPullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", -1, &a->wsnt__UnableToDestroySubscriptionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", -1, &a->wsnt__UnableToGetMessagesFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", -1, &a->wsnt__UnacceptableInitialTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", -1, &a->wsnt__UnacceptableTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", -1, &a->wsnt__UnrecognizedPolicyRequestFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", -1, &a->wsnt__UnsupportedPolicyRequestFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_wsnt__InvalidFilterFault = 1;
	size_t soap_flag_wsnt__InvalidMessageContentExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidProducerPropertiesExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidTopicExpressionFault = 1;
	size_t soap_flag_wsnt__MultipleTopicsSpecifiedFault = 1;
	size_t soap_flag_wsnt__NoCurrentMessageOnTopicFault = 1;
	size_t soap_flag_wsnt__NotifyMessageNotSupportedFault = 1;
	size_t soap_flag_wsnt__PauseFailedFault = 1;
	size_t soap_flag_tev__PullMessagesFaultResponse = 1;
	size_t soap_flag_wsrfr__ResourceUnknownFault = 1;
	size_t soap_flag_wsnt__ResumeFailedFault = 1;
	size_t soap_flag_wsnt__SubscribeCreationFailedFault = 1;
	size_t soap_flag_wsnt__TopicExpressionDialectUnknownFault = 1;
	size_t soap_flag_wsnt__TopicNotSupportedFault = 1;
	size_t soap_flag_wsnt__UnableToCreatePullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroyPullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroySubscriptionFault = 1;
	size_t soap_flag_wsnt__UnableToGetMessagesFault = 1;
	size_t soap_flag_wsnt__UnacceptableInitialTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnacceptableTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnrecognizedPolicyRequestFault = 1;
	size_t soap_flag_wsnt__UnsupportedPolicyRequestFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", &a->wsnt__InvalidFilterFault, "wsnt:InvalidFilterFaultType"))
				{	soap_flag_wsnt__InvalidFilterFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", &a->wsnt__InvalidMessageContentExpressionFault, "wsnt:InvalidMessageContentExpressionFaultType"))
				{	soap_flag_wsnt__InvalidMessageContentExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidProducerPropertiesExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", &a->wsnt__InvalidProducerPropertiesExpressionFault, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
				{	soap_flag_wsnt__InvalidProducerPropertiesExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", &a->wsnt__InvalidTopicExpressionFault, "wsnt:InvalidTopicExpressionFaultType"))
				{	soap_flag_wsnt__InvalidTopicExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__MultipleTopicsSpecifiedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", &a->wsnt__MultipleTopicsSpecifiedFault, "wsnt:MultipleTopicsSpecifiedFaultType"))
				{	soap_flag_wsnt__MultipleTopicsSpecifiedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NoCurrentMessageOnTopicFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", &a->wsnt__NoCurrentMessageOnTopicFault, "wsnt:NoCurrentMessageOnTopicFaultType"))
				{	soap_flag_wsnt__NoCurrentMessageOnTopicFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NotifyMessageNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", &a->wsnt__NotifyMessageNotSupportedFault, "wsnt:NotifyMessageNotSupportedFaultType"))
				{	soap_flag_wsnt__NotifyMessageNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__PauseFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", &a->wsnt__PauseFailedFault, "wsnt:PauseFailedFaultType"))
				{	soap_flag_wsnt__PauseFailedFault--;
					continue;
				}
			}
			if (soap_flag_tev__PullMessagesFaultResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", &a->tev__PullMessagesFaultResponse, ""))
				{	soap_flag_tev__PullMessagesFaultResponse--;
					continue;
				}
			}
			if (soap_flag_wsrfr__ResourceUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", &a->wsrfr__ResourceUnknownFault, "wsrfr:ResourceUnknownFaultType"))
				{	soap_flag_wsrfr__ResourceUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__ResumeFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", &a->wsnt__ResumeFailedFault, "wsnt:ResumeFailedFaultType"))
				{	soap_flag_wsnt__ResumeFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__SubscribeCreationFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", &a->wsnt__SubscribeCreationFailedFault, "wsnt:SubscribeCreationFailedFaultType"))
				{	soap_flag_wsnt__SubscribeCreationFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", &a->wsnt__TopicExpressionDialectUnknownFault, "wsnt:TopicExpressionDialectUnknownFaultType"))
				{	soap_flag_wsnt__TopicExpressionDialectUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", &a->wsnt__TopicNotSupportedFault, "wsnt:TopicNotSupportedFaultType"))
				{	soap_flag_wsnt__TopicNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToCreatePullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", &a->wsnt__UnableToCreatePullPointFault, "wsnt:UnableToCreatePullPointFaultType"))
				{	soap_flag_wsnt__UnableToCreatePullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroyPullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", &a->wsnt__UnableToDestroyPullPointFault, "wsnt:UnableToDestroyPullPointFaultType"))
				{	soap_flag_wsnt__UnableToDestroyPullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroySubscriptionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", &a->wsnt__UnableToDestroySubscriptionFault, "wsnt:UnableToDestroySubscriptionFaultType"))
				{	soap_flag_wsnt__UnableToDestroySubscriptionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToGetMessagesFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", &a->wsnt__UnableToGetMessagesFault, "wsnt:UnableToGetMessagesFaultType"))
				{	soap_flag_wsnt__UnableToGetMessagesFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableInitialTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", &a->wsnt__UnacceptableInitialTerminationTimeFault, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableInitialTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", &a->wsnt__UnacceptableTerminationTimeFault, "wsnt:UnacceptableTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnrecognizedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", &a->wsnt__UnrecognizedPolicyRequestFault, "wsnt:UnrecognizedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnrecognizedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnsupportedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", &a->wsnt__UnsupportedPolicyRequestFault, "wsnt:UnsupportedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnsupportedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_new_chan__ChannelInstanceType(struct soap *soap, int n)
{
	struct chan__ChannelInstanceType *p;
	struct chan__ChannelInstanceType *a = (struct chan__ChannelInstanceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct chan__ChannelInstanceType));
	for (p = a; p && n--; p++)
		soap_default_chan__ChannelInstanceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_new_wsa5__ProblemActionType(struct soap *soap, int n)
{
	struct wsa5__ProblemActionType *p;
	struct wsa5__ProblemActionType *a = (struct wsa5__ProblemActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ProblemActionType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ProblemActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_new_wsa5__RelatesToType(struct soap *soap, int n)
{
	struct wsa5__RelatesToType *p;
	struct wsa5__RelatesToType *a = (struct wsa5__RelatesToType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__RelatesToType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelatesToType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_new_wsa5__MetadataType(struct soap *soap, int n)
{
	struct wsa5__MetadataType *p;
	struct wsa5__MetadataType *a = (struct wsa5__MetadataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__MetadataType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__MetadataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa5__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa5__ReferenceParametersType *p;
	struct wsa5__ReferenceParametersType *a = (struct wsa5__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa5__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa5__EndpointReferenceType *p;
	struct wsa5__EndpointReferenceType *a = (struct wsa5__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse))
		soap_serialize__wsnt__ResumeSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeSubscriptionResponse **)soap_malloc(soap, sizeof(struct _wsnt__ResumeSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeSubscription))
		soap_serialize__wsnt__ResumeSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeSubscription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeSubscription **)soap_malloc(soap, sizeof(struct _wsnt__ResumeSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseSubscriptionResponse))
		soap_serialize__wsnt__PauseSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _wsnt__PauseSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseSubscriptionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseSubscriptionResponse **)soap_malloc(soap, sizeof(struct _wsnt__PauseSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseSubscription))
		soap_serialize__wsnt__PauseSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, struct _wsnt__PauseSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseSubscription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseSubscription **)soap_malloc(soap, sizeof(struct _wsnt__PauseSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__CreatePullPointResponse))
		soap_serialize__wsnt__CreatePullPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, struct _wsnt__CreatePullPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__CreatePullPointResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__CreatePullPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__CreatePullPointResponse **)soap_malloc(soap, sizeof(struct _wsnt__CreatePullPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__CreatePullPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__CreatePullPoint))
		soap_serialize__wsnt__CreatePullPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, struct _wsnt__CreatePullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__CreatePullPoint, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__CreatePullPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__CreatePullPoint **)soap_malloc(soap, sizeof(struct _wsnt__CreatePullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__CreatePullPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__DestroyPullPointResponse))
		soap_serialize__wsnt__DestroyPullPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, struct _wsnt__DestroyPullPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__DestroyPullPointResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__DestroyPullPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__DestroyPullPointResponse **)soap_malloc(soap, sizeof(struct _wsnt__DestroyPullPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__DestroyPullPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__DestroyPullPoint))
		soap_serialize__wsnt__DestroyPullPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, struct _wsnt__DestroyPullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__DestroyPullPoint, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__DestroyPullPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__DestroyPullPoint **)soap_malloc(soap, sizeof(struct _wsnt__DestroyPullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__DestroyPullPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetMessagesResponse))
		soap_serialize__wsnt__GetMessagesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, struct _wsnt__GetMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetMessagesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetMessagesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetMessagesResponse **)soap_malloc(soap, sizeof(struct _wsnt__GetMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetMessagesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetMessages))
		soap_serialize__wsnt__GetMessages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, int id, struct _wsnt__GetMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetMessages, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetMessages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetMessages ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetMessages **)soap_malloc(soap, sizeof(struct _wsnt__GetMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetMessages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Notify))
		soap_serialize__wsnt__Notify(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, int id, struct _wsnt__Notify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Notify, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Notify(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Notify ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Notify **)soap_malloc(soap, sizeof(struct _wsnt__Notify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Notify(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Notify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetCurrentMessageResponse))
		soap_serialize__wsnt__GetCurrentMessageResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, struct _wsnt__GetCurrentMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetCurrentMessageResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetCurrentMessageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetCurrentMessageResponse **)soap_malloc(soap, sizeof(struct _wsnt__GetCurrentMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetCurrentMessage))
		soap_serialize__wsnt__GetCurrentMessage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, struct _wsnt__GetCurrentMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetCurrentMessage, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetCurrentMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetCurrentMessage **)soap_malloc(soap, sizeof(struct _wsnt__GetCurrentMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetCurrentMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeResponse))
		soap_serialize__wsnt__SubscribeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeResponse **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe))
		soap_serialize__wsnt__Subscribe(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__RenewResponse))
		soap_serialize__wsnt__RenewResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__RenewResponse(struct soap *soap, const char *tag, int id, struct _wsnt__RenewResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__RenewResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__RenewResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__RenewResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__RenewResponse **)soap_malloc(soap, sizeof(struct _wsnt__RenewResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__RenewResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Renew))
		soap_serialize__wsnt__Renew(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, int id, struct _wsnt__Renew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Renew, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Renew(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Renew ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Renew **)soap_malloc(soap, sizeof(struct _wsnt__Renew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Renew(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Renew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventBrokersResponse))
		soap_serialize__tev__GetEventBrokersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventBrokersResponse(struct soap *soap, const char *tag, int id, struct _tev__GetEventBrokersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventBrokersResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventBrokersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventBrokersResponse(struct soap *soap, const char *tag, struct _tev__GetEventBrokersResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventBrokersResponse **)soap_malloc(soap, sizeof(struct _tev__GetEventBrokersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventBrokersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventBrokersResponse, sizeof(struct _tev__GetEventBrokersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetEventBrokersResponse(soap, tag ? tag : "tev:GetEventBrokersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventBrokersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventBrokers))
		soap_serialize__tev__GetEventBrokers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventBrokers(struct soap *soap, const char *tag, int id, struct _tev__GetEventBrokers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventBrokers, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventBrokers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventBrokers ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventBrokers(struct soap *soap, const char *tag, struct _tev__GetEventBrokers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventBrokers **)soap_malloc(soap, sizeof(struct _tev__GetEventBrokers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventBrokers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventBrokers, sizeof(struct _tev__GetEventBrokers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetEventBrokers(soap, tag ? tag : "tev:GetEventBrokers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokers ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventBrokers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__DeleteEventBrokerResponse))
		soap_serialize__tev__DeleteEventBrokerResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, int id, struct _tev__DeleteEventBrokerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__DeleteEventBrokerResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__DeleteEventBrokerResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__DeleteEventBrokerResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__DeleteEventBrokerResponse **)soap_malloc(soap, sizeof(struct _tev__DeleteEventBrokerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__DeleteEventBrokerResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBrokerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__DeleteEventBrokerResponse, sizeof(struct _tev__DeleteEventBrokerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__DeleteEventBrokerResponse(soap, tag ? tag : "tev:DeleteEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__DeleteEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__DeleteEventBroker))
		soap_serialize__tev__DeleteEventBroker(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__DeleteEventBroker(struct soap *soap, const char *tag, int id, struct _tev__DeleteEventBroker *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__DeleteEventBroker, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__DeleteEventBroker(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker ** SOAP_FMAC4 soap_in_PointerTo_tev__DeleteEventBroker(struct soap *soap, const char *tag, struct _tev__DeleteEventBroker **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__DeleteEventBroker **)soap_malloc(soap, sizeof(struct _tev__DeleteEventBroker *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__DeleteEventBroker(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBroker **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__DeleteEventBroker, sizeof(struct _tev__DeleteEventBroker), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__DeleteEventBroker(soap, tag ? tag : "tev:DeleteEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker ** SOAP_FMAC4 soap_get_PointerTo_tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__DeleteEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__AddEventBrokerResponse))
		soap_serialize__tev__AddEventBrokerResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__AddEventBrokerResponse(struct soap *soap, const char *tag, int id, struct _tev__AddEventBrokerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__AddEventBrokerResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__AddEventBrokerResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__AddEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__AddEventBrokerResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__AddEventBrokerResponse **)soap_malloc(soap, sizeof(struct _tev__AddEventBrokerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__AddEventBrokerResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__AddEventBrokerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__AddEventBrokerResponse, sizeof(struct _tev__AddEventBrokerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__AddEventBrokerResponse(soap, tag ? tag : "tev:AddEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__AddEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__AddEventBroker))
		soap_serialize__tev__AddEventBroker(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__AddEventBroker(struct soap *soap, const char *tag, int id, struct _tev__AddEventBroker *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__AddEventBroker, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__AddEventBroker(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__AddEventBroker ** SOAP_FMAC4 soap_in_PointerTo_tev__AddEventBroker(struct soap *soap, const char *tag, struct _tev__AddEventBroker **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__AddEventBroker **)soap_malloc(soap, sizeof(struct _tev__AddEventBroker *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__AddEventBroker(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__AddEventBroker **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__AddEventBroker, sizeof(struct _tev__AddEventBroker), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__AddEventBroker(soap, tag ? tag : "tev:AddEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBroker ** SOAP_FMAC4 soap_get_PointerTo_tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__AddEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventPropertiesResponse))
		soap_serialize__tev__GetEventPropertiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, struct _tev__GetEventPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventPropertiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventPropertiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, struct _tev__GetEventPropertiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventPropertiesResponse **)soap_malloc(soap, sizeof(struct _tev__GetEventPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventPropertiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetEventPropertiesResponse(soap, tag ? tag : "tev:GetEventPropertiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventProperties))
		soap_serialize__tev__GetEventProperties(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, int id, struct _tev__GetEventProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventProperties, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventProperties(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventProperties ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, struct _tev__GetEventProperties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventProperties **)soap_malloc(soap, sizeof(struct _tev__GetEventProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventProperties(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventProperties ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse))
		soap_serialize__tev__CreatePullPointSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscriptionResponse **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription))
		soap_serialize__tev__CreatePullPointSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscription **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse))
		soap_serialize__tev__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tev__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tev__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetServiceCapabilities))
		soap_serialize__tev__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tev__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tev__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsubscribeResponse))
		soap_serialize__wsnt__UnsubscribeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, struct _wsnt__UnsubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsubscribeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsubscribeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsubscribeResponse **)soap_malloc(soap, sizeof(struct _wsnt__UnsubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsubscribeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Unsubscribe))
		soap_serialize__wsnt__Unsubscribe(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, struct _wsnt__Unsubscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Unsubscribe, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Unsubscribe(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Unsubscribe **)soap_malloc(soap, sizeof(struct _wsnt__Unsubscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Unsubscribe(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SetSynchronizationPointResponse))
		soap_serialize__tev__SetSynchronizationPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _tev__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SetSynchronizationPointResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPointResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _tev__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__SetSynchronizationPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__SetSynchronizationPointResponse(soap, tag ? tag : "tev:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SetSynchronizationPoint))
		soap_serialize__tev__SetSynchronizationPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _tev__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SetSynchronizationPoint, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _tev__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__SetSynchronizationPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SeekResponse))
		soap_serialize__tev__SeekResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SeekResponse(struct soap *soap, const char *tag, int id, struct _tev__SeekResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SeekResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__SeekResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__SeekResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__SeekResponse(struct soap *soap, const char *tag, struct _tev__SeekResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__SeekResponse **)soap_malloc(soap, sizeof(struct _tev__SeekResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__SeekResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__SeekResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__SeekResponse(soap, tag ? tag : "tev:SeekResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SeekResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__Seek(struct soap *soap, struct _tev__Seek *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__Seek))
		soap_serialize__tev__Seek(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__Seek(struct soap *soap, const char *tag, int id, struct _tev__Seek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__Seek, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__Seek(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__Seek ** SOAP_FMAC4 soap_in_PointerTo_tev__Seek(struct soap *soap, const char *tag, struct _tev__Seek **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__Seek **)soap_malloc(soap, sizeof(struct _tev__Seek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__Seek(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__Seek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__Seek(struct soap *soap, struct _tev__Seek *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__Seek(soap, tag ? tag : "tev:Seek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__Seek ** SOAP_FMAC4 soap_get_PointerTo_tev__Seek(struct soap *soap, struct _tev__Seek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesResponse))
		soap_serialize__tev__PullMessagesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, struct _tev__PullMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessagesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessagesResponse **)soap_malloc(soap, sizeof(struct _tev__PullMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessagesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessages))
		soap_serialize__tev__PullMessages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, int id, struct _tev__PullMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessages, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessages ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessages **)soap_malloc(soap, sizeof(struct _tev__PullMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType))
		soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnsupportedPolicyRequestFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType))
		soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnrecognizedPolicyRequestFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType))
		soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnacceptableTerminationTimeFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType))
		soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableInitialTerminationTimeFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType))
		soap_serialize_wsnt__UnableToGetMessagesFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToGetMessagesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToGetMessagesFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToGetMessagesFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToGetMessagesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToGetMessagesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType))
		soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToDestroySubscriptionFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType))
		soap_serialize_wsnt__UnableToDestroyPullPointFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToDestroyPullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroyPullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToDestroyPullPointFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToDestroyPullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroyPullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType))
		soap_serialize_wsnt__UnableToCreatePullPointFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToCreatePullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToCreatePullPointFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToCreatePullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType))
		soap_serialize_wsnt__TopicNotSupportedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__TopicNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicNotSupportedFaultType **)soap_malloc(soap, sizeof(struct wsnt__TopicNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType))
		soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionDialectUnknownFaultType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType))
		soap_serialize_wsnt__SubscribeCreationFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__SubscribeCreationFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscribeCreationFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__SubscribeCreationFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__ResumeFailedFaultType))
		soap_serialize_wsnt__ResumeFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__ResumeFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__ResumeFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__ResumeFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__ResumeFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__ResumeFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType))
		soap_serialize_wsrfr__ResourceUnknownFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, struct wsrfr__ResourceUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsrfr__ResourceUnknownFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnknownFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrfr__ResourceUnknownFaultType **)soap_malloc(soap, sizeof(struct wsrfr__ResourceUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesFaultResponse))
		soap_serialize__tev__PullMessagesFaultResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, struct _tev__PullMessagesFaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesFaultResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessagesFaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessagesFaultResponse **)soap_malloc(soap, sizeof(struct _tev__PullMessagesFaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessagesFaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__PauseFailedFaultType))
		soap_serialize_wsnt__PauseFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__PauseFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__PauseFailedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__PauseFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__PauseFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__PauseFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType))
		soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__NotifyMessageNotSupportedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotifyMessageNotSupportedFaultType **)soap_malloc(soap, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType))
		soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct wsnt__NoCurrentMessageOnTopicFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NoCurrentMessageOnTopicFaultType **)soap_malloc(soap, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType))
		soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__MultipleTopicsSpecifiedFaultType **)soap_malloc(soap, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType))
		soap_serialize_wsnt__InvalidTopicExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidTopicExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidTopicExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidTopicExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType))
		soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType))
		soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidMessageContentExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidFilterFaultType))
		soap_serialize_wsnt__InvalidFilterFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidFilterFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidFilterFaultType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidFilterFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidFilterFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidFilterFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, struct _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(struct _wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		soap_serialize_wstop__TopicType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, struct wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_wstop__TopicType(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicType **)soap_malloc(soap, sizeof(struct wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		soap_serialize_wstop__QueryExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, struct wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__QueryExpressionType **)soap_malloc(soap, sizeof(struct wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause))
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description))
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode))
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause))
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description))
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode))
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description))
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause))
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description))
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause))
		soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description))
		soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode))
		soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		soap_serialize_wstop__Documentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, struct wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__Documentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__Documentation **)soap_malloc(soap, sizeof(struct wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__Documentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		soap_serialize_wsnt__SubscriptionPolicyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		soap_serialize_wsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__EventBrokerConfig))
		soap_serialize_tev__EventBrokerConfig(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__EventBrokerConfig(struct soap *soap, const char *tag, int id, struct tev__EventBrokerConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__EventBrokerConfig, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tev__EventBrokerConfig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tev__EventBrokerConfig ** SOAP_FMAC4 soap_in_PointerTotev__EventBrokerConfig(struct soap *soap, const char *tag, struct tev__EventBrokerConfig **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tev__EventBrokerConfig **)soap_malloc(soap, sizeof(struct tev__EventBrokerConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tev__EventBrokerConfig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tev__EventBrokerConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__EventBrokerConfig, sizeof(struct tev__EventBrokerConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotev__EventBrokerConfig(soap, tag ? tag : "tev:EventBrokerConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__EventBrokerConfig ** SOAP_FMAC4 soap_get_PointerTotev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__EventBrokerConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		soap_serialize_wstop__TopicSetType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, struct wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicSetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicSetType **)soap_malloc(soap, sizeof(struct wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicSetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		soap_serialize_wsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy))
		soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__Capabilities))
		soap_serialize_tev__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__Capabilities(struct soap *soap, const char *tag, int id, struct tev__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tev__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_in_PointerTotev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tev__Capabilities **)soap_malloc(soap, sizeof(struct tev__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tev__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_get_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		soap_serialize_wsnt__FilterType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, struct wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__FilterType **)soap_malloc(soap, sizeof(struct wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 5, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 5, 0, -1, "\\+?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 4, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
